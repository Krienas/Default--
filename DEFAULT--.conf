# conf file for DEFAULT-- flight script by TheGreatSardini
# Modified from DEFAULT ++ by Jeronimo

name: DEFAULT--v0.9

slots:
 core:
  class: CoreUnit
 gyro:
  class: GyroUnit
 DB:
  class: DataBankUnit
  select: manual
 shield:
  class: ShieldGeneratorUnit
 radar:
  class: RadarPVPUnit
  select: manual
 antigrav:
  class: AntiGravityGeneratorUnit
 warpdrive:
  class: WarpDriveUnit
 atmofueltank:
  class: AtmoFuelContainer
  select: manual
 spacefueltank:
  class: SpaceFuelContainer
  select: manual
 rocketfueltank:
  class: RocketFuelContainer
  select: manual
 switch:
  class: ManualSwitchUnit
  select: manual
 telemeter:
  class: TelemeterUnit
  select: manual
 vBooster:
  class: VerticalBooster
 hover:
  class: Hovercraft
handlers:
 unit:
  onStart:
   lua: |
    if #switch ~= 0 then switch_1.activate() end
    --q = q
    P = {
     w_title = "MAIN MENU",
     w_pos = {x=0, y=0},
     w_open = false,
     [1] = 'MS',
     [2] = 'ES',
     [3] = 'AS',
     [4] = 'WS',
     [5] = 'KP',
     [6] = 'Widgets_Custom',
     MS = {
      w_title = "MENU SETTINGS",
      w_pos = {x=5, y=50},
      w_open = true,
      [1] = 'TC',
      [2] = 'TCA',
      [3] = 'TTC',
      [4] = 'separator',
      [5] = 'WC',
      [6] = 'WCA',
      [7] = 'WTC',
      [8] = 'separator',
      [9] = 'BC',
      [10] = 'BBC',
      [11] = 'BCA',
      [12] = 'BTC',
      [13] = 'separator',
      [14] = 'wTC',
      [15] = 'wAC',
      [16] = 'WFC',
      [17] = 'separator',
      [18] = 'PRESET',
      [19] = 'separator',
      [20] = 'HELP_MENU',
      TC = {name = "TITLE COLOR", value = "white", range = {}, q = false},
      TCA = {name = "TITLE ALPHA", value = 1, range = {0,1}, step = {0.1, 0.05}, increment = 0.1, q = false},
      TTC = {name = "TITLE TEXT COLOR", value = "black", range = {}, q = false},
      WC = {name = "WINDOW COLOR", value = "midnightblue", range = {}, q = false},
      WCA = {name = "WINDOW ALPHA", value = 0.3, range = {0,1}, step = {0.1, 0.05}, increment = 0.1, q = false},
      WTC = {name = "WINDOW TEXT COLOR", value = "skyblue", range = {}, q = false},
      BC = {name = "BUTTON COLOR", value = "white", range = {}, q = false},
      BBC = {name = "BUTTON BORDER COLOR", value = "lightgray", range = {}, q = false},
      BCA = {name = "BUTTON ALPHA", value = 0.1, range = {0,1}, step = {0.1, 0.05}, increment = 0.1, q = false},
      BTC = {name = "BUTTON TEXT COLOR", value = "white", range = {}, q = false},
      wTC = {name = "WIDGET TEXT COLOR", value = "skyblue", range = {}, q = false},
      wAC = {name = "WIDGET SVG COLOR1", value = "red", range = {}, q = false},
      WFC = {name = "WIDGET SVG COLOR2", value = "white", range = {}, q = false},
      PRESET = {name = "COLOR PRESETS", value = "preset1", range = {"preset0","preset1","preset2","preset3","preset4","preset5"}, q = true},
      HELP_MENU = {name = "HELP MENU", value = function() P.help_menu.w_open = not P.help_menu.w_open
       end, q = false},
     },
     ES = {
      w_title = "ENGINE SETTINGS",
      w_pos = {x=270, y=50},
      w_open = true,
      [1 ] = 'pSF',
      [2 ] = 'ySF',
      [3 ] = 'rSF',
      [4 ] = 'anD',
      [5 ] = 'separator',
      [6 ] = 'loF',
      [7 ] = 'laF',
      [8 ] = 'vtF',
      [9 ] = 'separator',
      [10] = 'loB',
      [11] = 'laB',
      [12] = 'vtB',
      [13] = 'spB',
      [14] = 'separator',
      [15] = 'gyr',
      [16] = 'pAd',
      [17] = 'rAd',
      [18] = 'separator',
      [19] = 'hov',
      [20] = 'hoM',
      [21] = 'hoA',
      [22] = 'agA',
      [23] = 'separator',
      [24] = 'eng',
      [25] = 'aMS',
      [26] = 'separator',
      [27] = 'dCA',
      [28] = 'dSA',
      pSF = {name = "PITCH FACTOR", value = 1, range = {0,1}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      ySF = {name = "YAW FACTOR", value = 1, range = {0,1}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      rSF = {name = "ROLL FACTOR", value = 1, range = {0,1}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      anD = {name = "ANGULAR DAMPING", value = 0.2, range = {0,1}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      loF = {name = "LONG FACTOR", value = 1, range = {0,1}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      laF = {name = "LAT FACTOR", value = 1, range = {0,1}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      vtF = {name = "VERT FACTOR", value = 1, range = {0,1}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      loB = {name = "LONG BRAKE FACTOR", value = 1, range = {0,10}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      laB = {name = "LAT BRAKE FACTOR", value = 1, range = {0,10}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      vtB = {name = "VERT BRAKE FACTOR", value = 1, range = {0,10}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      spB = {name = "SPACE BRAKE INTENSITY", value = 1, range = {0,10}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      gyr = {name = "GYRO AXIS", value = "OFF", range = {"ON","CROSS","OFF"}, q = false},
      pAd = {name = "PITCH TILTING", value = 0, range = {-90,90}, step = {1, 45, 90}, increment = 1, q = false},
      rAd = {name = "ROLL TILTING", value = 0, range = {-90,90}, step = {1, 45, 90}, increment = 1, q = false},
      hov = {name = "HOVERS ON/OFF", value = "ON", range = {"ON","OFF"}, q = false},
      hoM = {name = "HOVERS MODE", value = "DYNAMIC", range = {"DYNAMIC","STATIC"}, q = true},
      hoA = {name = "HOVERS ALTITUDE", value = 5, range = {-9999,50}, step = {0.1, 1, 5, 100}, increment = 1, q = true},
      agA = {name = "AGG ALTITUDE", value = 1000, range = {1000,500000}, step = {1, 10, 100, 1000, 10000}, increment = 100, q = false},
      eng = {name = "ENGINES ON/OFF", value = "AUTO", range = {"ON","OFF","AUTO"}, q = false},
      aMS = {name = "ATMO MAX SPEED", value = math.floor(construct.getFrictionBurnSpeed()*3.6), range = {-1,29999}, step = {1, 10, 100}, increment = 10, q = false},
      dCA = {name = "DRONE CRUISE ANGLE", value = 22, range = {1,88}, step = {1, 5, 10}, increment = 1, q = false},
      dSA = {name = "DRONE SHIFT ANGLE", value = 60, range = {1,88}, step = {1, 5, 10}, increment = 1, q = false}
     },
     AS = {
      w_title = "AUTO-ASSIST SETTINGS",
      w_pos = {x=535, y=50},
      w_open = true,
      [1] = 'aBS',
      [2] = 'separator',
      [3] = 'stA',
      [4] = 'auR',
      [5] = 'tuA',
      [6] = 'tAR',
      [7] = 'tAP',
      [8] = 'separator',
      [9] = 'auP',
      [10] = 'aPA',
      [11] = 'atS',
      [12] = 'anS',
      [13] = 'separator',
      [14] = 'iAB',
      [15] = 'aAD',
      [16] = 'sAD',
      [17] = 'aPG',
      [18] = 'aOS',
      [19] = 'separator',
      [20] = 'rMS',
      [21] = 'separator',
      [22] = 'dok',
      [23] = 'separator',
      [24] = 'bBu',
      [25] = 'aLR',
      [26] = 'grO',
      aBS = {name = "AUTO BRAKE SPEED", value = 100, range = {0,1000}, step = {1, 5, 10}, increment = 1, q = false},
      stA = {name = "AUTO LEVEL ALT. MAX", value = 200000, range = {-2000,500000}, step = {100, 1000, 10000}, increment = 100, q = false},
      auR = {name = "ROLL STABILISATION", value = true, q = false},
      tuA = {name = "TURN ASSIST", value = false, q = true},
      tAR = {name = "TURN ASSIST MIN ROLL", value = 3, range = {1,90}, step = {1, 5, 10}, increment = 1, q = false},
      tAP = {name = "TURN ASSIST MAX PITCH", value = 45, range = {1,90}, step = {1, 5, 10}, increment = 1, q = false},
      auP = {name = "PITCH STABILISATION", value = true, q = false},
      aPA = {name = "AUTO PITCH AMPLITUDE", value = 2, range = {1,90}, step = {0.5, 1, 5}, increment = 1, q = false},
      atS = {name = "ALTITUDE STABILISATION", value = true, q = false},
      anS = {name = "ATMO ANTI-STALL", value = false, q = false},
      iAB = {name = "INERTIA AUTO BRAKE", value = true, q = true},
      aAD = {name = "ATMO INERTIA FACTOR", value = 0.95, range = {0,1}, step = {0.001, 0.01, 0.1}, increment = 0.01, q = false},
      sAD = {name = "SPACE INERTIA FACTOR", value = 0.60, range = {0,1}, step = {0.001, 0.01, 0.1}, increment = 0.01, q = false},
      aPG = {name = "SPACE AUTO PROGRADE", value = false, q = false},
      aOS = {name = "AUTO ORBIT SPEED", value = false, q = false},
      rMS = {name = "ROCKETS MAX SPEED", value = 1200, range = {-1,29999}, step = {1, 10, 100}, increment = 10, q = false},
      dok = {name = "DOCKING PARENT", value = "MANUAL", range = {"MANUAL","OWNER","CLOSEST"}, q = false},
      bBu = {name = "BACK BURN", value = false, q = false},
      aLR = {name = "AUTO LAND FACTOR", value = 0.7, range = {0,1.1}, step = {0.001, 0.01, 0.1}, increment = 0.1, q = false},
      grO = {name = "GROUND OFFSET", value = 3, range = {0,50}, step = {0.1, 1}, increment = 1, q = false},
     },
     WS = {
      w_title = "WIDGETS",
      w_pos = {x=800, y=50},
      w_open = true,
      [1] = 'w_hud',
      [2] = 'w_info',
      [3] = 'w_platform',
      [4] = 'w_speedometer',
      [5] = 'w_gyro',
      [6] = 'w_fuel',
      [7] = 'separator',
      [8] = 'w_core',
      [9] = 'w_agg',
      [10] = 'w_warp',
      [11] = 'w_parenting',
      [12] = 'w_cstress',
      [13] = 'w_shield',
      [14] = 'separator',
      [15] = 'w_periscope',
      [16] = 'w_radar',
      [17] = 'w_refresh',
      w_hud = {name = "HUD", value = "Default --", range = {"Default --","None"}, q = false},
      w_info = {name = "INFO", value = "Default --", range = {"Default --","None"}, q = false},
      w_platform = {name = "PLATFORM HUD", value = "Default --", range = {"Default --","None"}, q = false},
      w_speedometer = {name = "SPEEDOMETER", value = "None", range = {"Default", "None"}, q = false},
      w_gyro = {name = "GYROSCOPE", value = "None", range = {"Default", "None"}, q = false},
      w_fuel = {name = "FUEL TANKS", value = "None", range = {"Default", "None"}, q = false},
      w_core = {name = "CORE", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_agg = {name = "AGG", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_warp = {name = "WARP DRIVE", value = "None", range = {"Default", "ALT", "Auto", "None"}, q = false},
      w_parenting = {name = "PARENTING", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_cstress = {name = "COMBAT STRESS", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_shield = {name = "SHIELD", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_periscope = {name = "PERISCOPE", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_radar = {name = "RADAR", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_refresh = {name = "GUI REFRESH RATE", value = 0.01, range = {0.001,1}, step = {0.001, 0.01, 0.1}, increment = 0.001, q = false},
     },
     KP = {
      w_title = "KEYBIND PARAMETERS",
      w_pos = {x=1065, y=50},
      w_open = true,
      [1] = 'flM',
      [2] = 'pkM',
      [3] = 'pMS',
      [4] = 'separator',
      [5] = 'iCo',
      [6] = 'separator',
      [7] = 'dTT',
      [8] = 'shL',
      [9] = 'geL',
      [10] = 'separator',
      [11] = 'mvL',
      [12] = 'viL',
      [13] = 'moC',
      [14] = 'mCS',
      [15] = 'separator',
      [16] = 'flightModeKB',
      [17] = 'mouseControlKB',
      [18] = 'movementLockKB',
      [19] = 'altitudeAP',
      [20] = 'viewLockKB',
      [21] = 'speedLockKB',
      [22] = 'showScreenKB',
      flM = {name = "FLIGHT MODE", value = "TRAVEL", range = {"CRUISE","TRAVEL","PLATFORM","DRONE"}, q = true},
      pkM = {name = "PARKING MODE", value = "PLATFORM", range = {"PLATFORM","DRONE","OFF"}, q = true},
      pMS = {name = "PARKING MAX SPEED", value = 50, range = {0,29999}, step = {1, 10, 100}, increment = 1, q = false},
      iCo = {name = "QE/AD INVERT", value = false, q = false},
      dTT = {name = "DOUBLE TAP TIME", value = 0.25, range = {0.01,1}, step = {0.01, 0.1}, increment = 0.01, q = false},
      shL = {name = "SHIFT LOCK", value = false, q = false},
      geL = {name = "G TOGGLES PARKING", value = false, q = false},
      mvL = {name = "FREEZE MOVEMENT", value = false, q = false},
      viL = {name = "FREEZE VIEW", value = false, q = false},
      moC = {name = "MOUSE CONTROL", value = false, q = false},
      mCS = {name = "M-C SENSITIVITY", value = 0.3, range = {0.01,10}, step = {0.01,0.1, 1}, increment = 0.1, q = false},
      flightModeKB = {name = "FLIGHT MODE KB", value = "ALT+3", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
      mouseControlKB = {name = "MOUSE CONTROL KB", value = "ALT+4", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
      movementLockKB = {name = "MOVEMENT FREEZE KB", value = "ALT+5", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
      altitudeAP = {name = "10％ Atmo KB", value = "ALT+6", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
      viewLockKB = {name = "VIEW FREEZE KB", value = "ALT+7", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
      speedLockKB = {name = "ATMO SPEED LOCK KB", value = "ALT+8", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
      showScreenKB = {name = "SHOW HUDS KB", value = "ALT+9", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
     },
     Widgets_Custom = {
      w_title = "CUSTOM WIDGETS",
      w_pos = {x=1330, y=50},
      w_open = true,
     },
     Widget_Info = {
      w_title = "INFO",
      w_pos = {x=0, y=0},
      w_open = true,
      w_scale = 1,
     },
     QuickToolBar = {
      w_title = "QUICK TOOL BAR",
      w_pos = {x=770, y=500},
      w_open = false
     },
     help_menu = {
      w_title = "HELP",
      w_pos = {x=720, y=580},
      w_open = false,
      w_html = "INSTRUCTION MANUAL",
      [1] = 'separator',
      [2] = 'Info_Page',
      [3] = 'separator',
      [4] = 'separator',
      [5] = 'MS',
      [6] = 'separator',
      [7] = 'ES',
      [8] = 'separator',
      [9] = 'AS',
      [10] = 'separator',
      [11] = 'WS',
      [12] = 'separator',
      [13] = 'KP',
      [14] = 'separator',
      [15] = 'QuickToolBar',
      [16] = 'separator',
      [17] = 'separator',
      Info_Page = {name = "INSTRUCTION MANUAL", html = ""},
      MS = {name = "MENU SETTINGS", html = ""},
      ES = {name = "ENGINES SETTINGS", html = ""},
      AS = {name = "AUTOPILOT SETTINGS", html = ""},
      WS = {name = "WIDGET SETTINGS", html = ""},
      KP = {name = "KEYBIND PARAMS", html = ""},
      QuickToolBar = {name = "QUICK TOOL BAR", html = ""}
     }
    }
    script = {}
    script = {
     version = 0.9,
     start = function()
      system.print("Script initialisation started")
      onStartParams()
      system.print("On start P loaded")
      getGlobals()
      system.print("Globals loaded")
      system.print("Closest planet: "..Helios[closestPlanetIndex].name[1])
      script.onTickData()
      setParamsFuelTanks()
      system.print("Fuel tanks loaded: "..#fuelTanksData)
      loadParamsFromDB()
      previousPreset = P.MS.PRESET.value
      loadColorPreset()
      updateHelpMenu()
      system.print("Help menu updated")
      paramsSetColorsRange()
      system.print("Color range updated")
      WindowLib:winlibCSSUpdate()
      system.print("Winlibcss updated")
      if P.w_open == true then windowsShow() else windowsHide() end
      system.print("Widgets display updated")
      WindowLib:update()
      system.print("Winlib updated")
      updateParams()
      system.print("Params updated")
      if P.ES.eng.value == "ON" then enginesToggle() end
      system.print("Script initialisation successfull")
      hasFinishedLoading = true
      --help.print(system)
      unit.setTimer("DATA",0.5)
      unit.setTimer("SCREEN",P.WS.w_refresh.value)
      unit.setTimer("FPS",1)
      unit.setTimer("BACKUP",30)
      unit.setTimer("TENTHS",0.1)
     end,

     stop = function()
      system.print("Saving parameters into Databank")
      if reset == false and hasFinishedLoading == true then setParams2DB() end 
      reset = false
      windowsHide()
      system.showScreen(0)
      if #switch ~= 0 then switch_1.deactivate() end
     end,

     update = function()
      if ALT == false and P.w_open == false and P.QuickToolBar.w_open == false then--and Engines == true then
       Nav:throttleUpdate()
      end
      if ALT == true or P.w_open == true or P.QuickToolBar.w_open == true then WindowLib:update() end
      if WindowLib.wlib_drag == true then WindowLib:performDrag() end
      
      if P.KP.moC.value == true and P.w_open == false and ALT == false then
       mouseControlUpdate()
      end
      if P.w_open == true or P.QuickToolBar.w_open == true then
       system.lockView(1)
      elseif P.KP.moC.value == true and ALT == true then
       system.lockView(0)
      end
      currentTime = system.getArkTime()
      uCount = uCount + 1
      updateGyro()
      updateGear()
     end,

     onTickData = function()
      local ind = 1
      local function decodeJSON(json)
       local decodedInput = string.gsub(json, "%\\u(%x%x%x%x)", function(a) return utf8.char(tonumber(a,16))end)
       return load('return ' .. decodedInput:gsub('[[]', '{'):gsub('[]]', '}'):gsub('"(%w+)":', '["%1"]='))()
      end
      getGlobals()
      fuelTanksData = {}
      if fueltanks then
       for i , v in ipairs(fueltanks) do
        fuelTanksData[i] = {}
        local decodeFT = decodeJSON(v.getWidgetData())
        fuelTanksData[i].name = decodeFT.name or "LOADING"
        fuelTanksData[i].percentage = decodeFT.percentage or 0.01
        fuelTanksData[i].timeLeft = decodeFT.timeLeft ~= "n/a" and decodeFT.timeLeft or 0.01
       end
      end
      if DB_1 ~= nil and DB_1.getStringValue("fueltanks") and DB_1.getStringValue("fueltanks") ~= "" then
       local function merge(t1, t2)
        if type(t1) ~= "table" or type(t2)~= "table" then return nil end
        local newT = t1
        for k,v in pairs(t2) do
         newT[ind] = v
         ind = ind + 1
        end 
        return newT
       end
       fuelTanksData = merge(fuelTanksData,Data:deserialize(DB_1.getStringValue("fueltanks"))) or fuelTanksData
      end
      local ftdl = #fuelTanksData
      if ftdl ~= 0 then table.sort(fuelTanksData, function(a,b) return a.name < b.name end) end
      if prevFTD ~= ftdl and ftdl ~= 0 then
       setParamsFuelTanks()
      end
      prevFTD = ftdl
      local decodeCU = decodeJSON(unit.getWidgetData())
      unitData.acceleration = decodeCU.acceleration or 0
      unitData.maxBrake = decodeCU.maxBrake or 0
      unitData.currentBrake = decodeCU.currentBrake or 0
      unitData.atmoThrust = decodeCU.atmoThrust or 0
      unitData.spaceThrust = decodeCU.spaceThrust or 0
      unitData.unitOverLoad = decodeCU.showOverload or 0
      unitData.maxSpeedkph = decodeCU.maxSpeed ~= nil and decodeCU.maxSpeed-1 or 0
      unitData.maxSpeedMPS = unitData.maxSpeedkph * 0.27777777777
      Nav:updateMaxSpeed(unitData.maxSpeedkph)
      if antigrav then
       local decodeAGG = decodeJSON(antigrav.getWidgetData())
       aggData.Power = decodeAGG.antiGPower ~= nil and (math.floor(decodeAGG["antiGPower"]*100).."/100") or "LOADING"
       aggData.Field = decodeAGG.antiGravityField ~= nil and math.floor(decodeAGG["antiGravityField"]*100).."Es" or "LOADING"
       aggData.Altitude = decodeAGG.baseAltitude ~= nil and decodeAGG.baseAltitude or "LOADING"
       aggData.State = antigrav.isActive() == true and "ON" or "OFF"
      end
      if warpdrive then
       local decodeW = decodeJSON(warpdrive.getWidgetData())
       warpData.Info = decodeW.buttonMsg or "LOADING"
       warpData.Cells = decodeW.cellCount or 0
       warpData.Destination = decodeW.destination or "LOADING"
       warpData.Distance = decodeW.distance or "LOADING"
      end
      local dockingmode = 1
      if P.AS.dok.value == "CLOSEST" then dockingmode = 2 elseif P.AS.dok.value == "OWNER" then dockingmode = 3 end
      if construct.getDockingMode() ~= dockingmode then construct.setDockingMode(dockingmode) end
     end,

     onTickScreen = function()
      if ALT == false and P.w_open == false and P.QuickToolBar.w_open == false then WindowLib:update() end
     end,

     luaInput = function(text)
      if string.sub(text,1,5) == "reset" then
       if #DB == 0 then
        system.print("No DB Detected, Attach Databank and re-load flight script.")
        return
       end
       if text:lower() == "reset all" then
        Data:ResetAll()
        system.print("Databank has been reset, please log off the piloting chair for it to take effect") 
        reset = true 
        unit.exit()
       elseif string.sub(text,1,11) == "reset other"  then
        WipeAndReSave()
       else
        ResetUser()
       end
      elseif string.sub(text,1,6) == "::pos{" then
       local px, py, pz = convertToWorldCoordinates(text)
       system.print(px.." : "..py.." : "..pz)
      elseif text:lower() == "help" then 
       help.print(system) 
      end
     end,

     receive = function(channel,message)
     end,

     onActionStart = function(action)
      keyBindsOnStartControl(action)
     end,

     onActionStop = function(action)
      keyBindsOnStopControl(action)
     end,

     onActionLoop = function(action)
      keyBindsOnLoopControl(action)
     end,
    }
    script.start()

  onStop:
   lua: |
    script.stop()

  onTimer:
   args: ["DATA"]
   lua: |
    script.onTickData()

  onTimer:
   args: ["SCREEN"]
   lua: |
    script.onTickScreen()

  onTimer:
   args: ["FPS"]
   lua: |
    fps = uCount
    uCount = 0

  onTimer:
   args: ["BACKUP"]
   lua: |
    if reset == false and hasFinishedLoading == true then setParams2DB() end

 system:
  onUpdate:
   lua: |
    script.update()
  onFlush:
   lua: |
    thrustManager()
    
  onActionStart(action):
   lua: |
    script.onActionStart(action)
    
  onActionStop(action):
   lua: |
    script.onActionStop(action)
     
  onActionLoop(action):
   lua: |
    script.onActionLoop(action)
    
  onInputText(text):
   lua: |
    script.luaInput(text)
    
  onActionStart:
   args: [booster]
   lua: |
    unit.setEngineThrust('rocket_engine',1)
    system.print("boosters on")
    if Nav:getMasterMode() == "CRUISE" then
     PreviousMasterMode = "CRUISE"
     Nav:setMasterMode("TRAVEL")
    end
    boosterInput = 1
    Nav:setThrottleValue(1)
    
  onActionStop:
   args: [booster]
   lua: |
    boosterInput = 0
    unit.setEngineThrust('rocket_engine',0)
    if PreviousMasterMode == "CRUISE" then Nav:setMasterMode("CRUISE") end
    system.print("boosters off")
    
  onActionLoop:
   args: [booster]
   lua: |
    if xyzSpeedKPH > P.AS.rMS.value and inAtmo and boosterInput == 1 then
     unit.setEngineThrust('rocket_engine',0)
     if PreviousMasterMode == "CRUISE" then Nav:setMasterMode("CRUISE") end
     boosterInput = 0
     system.print("boosters off")
    end


 library:
  onStart:
   lua: |
    -- Data --
    dtbk = {}
    dtbk.__index = dtbk;
    function dtbk.new(bank)
     local self = setmetatable({}, dtbk)
     self.DB = bank
     self.concat = table.concat
     return self
    end
    function dtbk.getString(self,tag)
     return self.DB.getStringValue(tag)
    end
    function dtbk.setString(self,tag,value)
     self.DB.setStringValue(tag,value)
    end
    function dtbk.setData(self,tag,value)
     local str = self:serialize(value)
     self.DB.setStringValue(tag,str)
    end
    function dtbk.remove(self,key)
     self.DB.clearValue(key)
    end
    function dtbk.getData(self,tag)
     local str = self:deserialize(self.DB.getStringValue(tag))
     return str
    end
    function dtbk.ResetAll(self)
     self.DB.clear()
    end
    function dtbk.internalSerialize(self,table, tC, t)
     t[tC] = "{"
     tC = tC + 1
     if #table == 0 then
      local hasValue = false
      for key, value in pairs(table) do
       hasValue = true
       local keyType = type(key)
       if keyType == "string" then t[tC] = key .. "="
       elseif keyType == "number" then t[tC] = "[" .. key .. "]="
       elseif keyType == "boolean" then t[tC] = "[" .. tostring(key) .. "]="
       else t[tC] = "notsupported="
       end
       tC = tC + 1
       local check = type(value)
       if check == "table" then tC = self:internalSerialize(value, tC, t)
       elseif check == "string" then t[tC] = '"' .. value .. '"'
       elseif check == "number" then t[tC] = value
       elseif check == "boolean" then t[tC] = tostring(value)
       else t[tC] = '"Not Supported by Deserializer"'
       end
       t[tC + 1] = ","
       tC = tC + 2
      end
      if hasValue then
       tC = tC - 1
      end
     else
      for i = 1, #table do
       local value = table[i]
       local check = type(value)
       if check == "table" then tC = self:internalSerialize(value, tC, t)
       elseif check == "string" then t[tC] = '"' .. value .. '"'
       elseif check == "number" then t[tC] = value
       elseif check == "boolean" then t[tC] = tostring(value)
       else t[tC] = '"Not Supported by Deserializer"'
       end
       t[tC + 1] = ","
       tC = tC + 2
      end
      tC = tC - 1
     end
     t[tC] = "}"
     return tC
    end
    function dtbk.serialize(self,value)
     local t = {}
     local check = type(value)
     if check == "table" then
      self:internalSerialize(value, 1, t)
     elseif check == "string" then
      return '"' .. value .. '"'
     elseif check == "number" then
      return value
     elseif check == "boolean" then
      return tostring(value)
     else
      return '"Not Supported by Deserializer"'
     end
     return self.concat(t)
    end
    function dtbk.deserialize(self,s)
     return load("return " .. s)()
    end

    function ResetUser()
     local user = player.getId()
     local masterUser = Data:getData("masterUserID")
     Data:remove(tostring(user))
     if masterUser and masterUser == user then
      Data:remove("masterUserID")
     end
     system.print("Player: "..system.getPlayerName(user).."'s data has been reset") 
     reset = true 
     unit.exit()
    end

    function WipeAndReSave()
     Data:ResetAll()
     setParams2DB()
     system.print("current user is now the only profile on databank")
    end

    function checkMasterUser()
     if not Data:getData("masterUserID") then system.print("Setting Master user"); Data:setData("masterUserID",player.getId()) end
     return Data:getData("masterUserID")
    end

    local function currentUser()
     local masterUser = checkMasterUser()
     local userID = player.getId()
     local userName = player.getName()

     if not PerUserSaves and masterUser and masterUser ~= userID then --perUserSaves turned off, and I'm not master user
      local d2L = Data:getData(tostring(player.getId()))
      if not d2L or type(d2L) ~= "table" then --if my data not found then I'm now "Other" user
       userID = 0
       userName = "Other"
      end
     end
     return userID, userName, masterUser
    end

    PerUserSaves = true --export: Save ALL users separately (max of around 6 users in 1 databank) false = other users share one profile
    function setParams2DB()
     if #DB ~= 0 then
      local data2Save = {
      ["MBP"] = P.w_pos,
      ["QMP"] = P.QuickToolBar.w_pos,
      ["MBO"] = P.w_open,
      ["V"] = script.version,
      ["CP"] = colorPresets,
      ["HMP"] = P.help_menu.w_pos,
      ["HMO"] = P.help_menu.w_open,
      }
      for i, v in ipairs(P) do
       if P[v].w_pos ~= nil then
        data2Save[tostring(v).."_w_p"] = P[v].w_pos
        data2Save[tostring(v).."_w_o"] = P[v].w_open
       end
       for k, l in ipairs(P[v]) do
        if P[v][l] then
         if P[v][l].value ~= nil  then
          if type(P[v][l].value) ~= "function" then
           data2Save[tostring(v)..tostring(l).."_v"] = P[v][l].value
          end
          data2Save[tostring(v)..tostring(l).."_q"] = P[v][l].q
         end
        end
       end
      end
      for k, v in pairs(P) do
       if string.sub (tostring(k),1,7) == "Widget_" then
        data2Save[tostring(k).."_w_p"] = P[k].w_pos
        data2Save[tostring(k).."_w_o"] = P[k].w_open
        data2Save[tostring(k).."_w_s"] = P[k].w_scale
       end
      end
      data2Save["CT"] = Nav:getThrottleValue()
      data2Save["E"] = Engines

      local userId, userName, masterUser = currentUser()
      Data:setData(tostring(userId),data2Save)
      --system.print(userName.."'s data saved: "..string.len(Data:serialize(data2Save)).." characters")
     end
    end

    local masterDataID = true --export: will use construct owner data as default for new users
    function loadParamsFromDB()
     local SP = system.print
     local PE = function(t) SP(t.." data corrupted: using default parameter") end --print error message
     if #DB ~= 0 then
      SP("Initiating Databank loading")
      local userId, userName, masterUser = currentUser()
      local d2L = Data:getData(tostring(userId))

      local nU = false --new User using master profile
      if not d2L and masterDataID == true then
       nU = true 
       d2L = Data:getData(tostring(masterUser))
      end

      if d2L and type(d2L) == "table" then
       SP("Loading parameters from Databank")
       if nU == false then
        val = d2L["MBP"]
        if type(val) == "table" then
         P.w_pos = vec2(val)
        else
         PE("Menu_Bar_Pos")
        end
        val = d2L["QMP"]
        if type(val) == "table" then
         P.QuickToolBar.w_pos = vec2(val)
        else
         PE("Quick_Menu_Pos")
        end
        val = d2L["MBO"]
        if type(val) == "boolean" then
         P.w_open = val
        else
         PE("Menu_Bar_Open")
        end
        val = d2L["CP"]
        --system.print("colorPresets="..string.len(Data:serialize(val)))
        if type(val) == "table" then
         colorPresets = val
        else
         PE("colorPresets")
        end
        val = d2L["HMP"]
        if type(val) == "table" then
         P.help_menu.w_pos = vec2(val)
        else
         PE("Help_Menu_Pos")
        end
        val = d2L["HMO"]
        if type(val) == "boolean" then
         P.help_menu.w_open = val
        else
         PE("Help_Menu_Open")
        end
       end
       for i, v in ipairs(P) do
        if P[v].w_pos ~= nil then
         if type(d2L[tostring(v).."_w_p"]) == "table" and nU == false then
          P[v].w_pos = vec2(d2L[tostring(v).."_w_p"])
         else
          PE(tostring(v).."_w_pos")
         end
         if type(d2L[tostring(v).."_w_o"]) == "boolean" and nU == false then
          P[v].w_open = d2L[tostring(v).."_w_o"]
         else
          PE(tostring(v).."_w_open")
         end
        end
        for k, l in ipairs(P[v]) do
         if P[v][l] then
          if P[v][l].value ~= nil then
           if type(P[v][l].value) ~= "function" then
            val = d2L[tostring(v)..tostring(l).."_v"]
            if type(val) == type(P[v][l].value) then
             P[v][l].value = val
            else
             PE(tostring(v)..tostring(l).."_value")
            end
           end
           val = d2L[tostring(v)..tostring(l).."_q"]
           if type(val) == "boolean" then
            P[v][l].q = val
           else
            PE(tostring(v)..tostring(l).."_quick")
           end
          end
         end
        end
       end
       for i, v in pairs(P) do
        if string.sub(tostring(i),1,7) == "Widget_" then
         val = d2L[tostring(i).."_w_p"]
         if type(val) == "table" and nU == false then
          P[i].w_pos = vec2(val)
         else
          PE(tostring(i).."_w_pos")
         end
         val = d2L[tostring(i).."_w_o"]
         if type(val) == "boolean" then
          P[i].w_open = val
         else
          PE(tostring(i).."_w_open")
         end
         val = d2L[tostring(i).."_w_s"]
         if type(val) == "number" and nU == false then
          P[i].w_scale = val
         else
          PE(tostring(i).."_w_scale")
         end
        end
       end
       val = d2L["CT"]
       if type(val) == "number" then
        Nav:setThrottleValue(val)
       else
        PE("currentthrottle")
       end
       val = d2L["E"]
       if type(val) == "boolean" then
        Engines = val
       else
        PE("eng")
       end
       val = nil
       d2L = nil
       SP(userName.."'s data loaded successful.")

      else SP("No data found for player: "..userName.."! Loading default paramters")
      end
     end
    end
  onStart:
   lua: | 
    -- Widgets --
    local utils = require("cpml/utils")
    local abs, floor, format, sub, acos, sqrt, cos, sin, deg, ceil, clamp ,sign= math.abs, math.floor, string.format, string.sub, math.acos, math.sqrt, math.cos, math.sin, math.deg, math.ceil, utils.clamp, utils.sign
    local widget_font = "Play"

    WidgetsPlusPlus = {}
    WidgetsPlusPlus.__index = WidgetsPlusPlus

    function WidgetsPlusPlus.new()
     local self = setmetatable({}, WidgetsPlusPlus)
     self.width = system.getScreenWidth()
     self.height = system.getScreenHeight()
     -- HUD Setup -- 
     self.hudSVGSize = {x=1600,y=1000}
     P.Widget_HUD = {
      w_title = "HUD",
      w_pos = {x=self.width/2 -self.hudSVGSize.x/2, y=self.height/2 -self.hudSVGSize.y/2},
      w_size = self.hudSVGSize,
      w_open = false,
      w_scale = 1
     }
     -- Platform HUD Setup -- 
     self.platSVGSize = {x=204,y=104}
     local scale = 2
     P.Widget_Platform = {
      w_title = "Platform",
      w_pos = {x=self.width/2 -(self.platSVGSize.x*scale)/2, y=self.height*0.9 -(self.platSVGSize.y*scale)},
      w_size = self.platSVGSize,
      w_open = false,
      w_scale = scale
     }
     return self
    end

    -- HUD Widget --
    local SVGfuelText = {}
    local SVGfuelTextBool = {}
    local fuelCounter = 1

    function WidgetsPlusPlus.HUD_Update(self)
     local WFC = P.MS.WFC.value
     local WTC = P.MS.wTC.value
     local WAC = P.MS.wAC.value
     local temp1 = [[ font-family="]]..widget_font..[[" alignment-baseline="middle" stroke-width="0" fill="]]..WTC..[[">]]
     local SVGfinal = ""
     local SVGfixed = [[
      <clipPath id="clipcircle400"><rect x="0" y="300" width="1600" height="400" /></clipPath>
      <circle cx="800" cy="500" r="600" stroke-width="2" stroke="]]..WFC..[[" fill="none" clip-path="url(#clipcircle400)"/>
      <line id="bar1600" x1="235" y1="300" x2="214" y2= "300" stroke-width="2" stroke="]]..WFC..[["/>
      <use xlink:href="#bar1600" transform="rotate(180 800 500)"/>
      <line id="bar2600" x1="235" y1="700" x2="214" y2= "700" stroke-width="2" stroke="]]..WFC..[["/>
      <use xlink:href="#bar2600" transform="rotate(180 800 500)"/>
      <line x1="200" y1="500" x2="180" y2= "500" stroke-width="2" stroke="]]..WFC..[["/>
      <polygon id="triangle600" points="200 500, 201 505, 212 500, 201 495" stroke-width="0" fill="]]..WFC..[["/>
      <use xlink:href="#triangle600" transform="rotate(180 800 500)"/>
      <line x1="770" y1="500" x2="790" y2= "500" stroke-width="2" stroke="]]..WFC..[["/>
      <line x1="810" y1="500" x2="830" y2= "500" stroke-width="2" stroke="]]..WFC..[["/>
      <line x1="800" y1="470" x2="800" y2= "490" stroke-width="2" stroke="]]..WFC..[["/>
      <line x1="800" y1="510" x2="800" y2= "530" stroke-width="2" stroke="]]..WFC..[["/>
      <polygon points="800 897.5, 807 887.5, 793 887.5" stroke-width="0" fill="]]..WFC..[["/>
     ]]
     local indicatorColor = WFC
     if Engines == false then indicatorColor = "red" end
     local SVGrecindicator = [[
      <rect x="215" y="480" width="120" height="40" stroke="]]..indicatorColor..[[" fill="none"/>
      <rect x="1265" y="480" width="120" height="40" stroke="]]..indicatorColor..[[" fill="none"/>
     ]]
     local SVGaltitude = [[
      <text x="275" y="500" font-size="20" text-anchor="middle"]]..temp1..format("%.0f", alt).."m"..[[</text>
     ]]
     local throttleText = 0
     if MM == "TRAVEL" then 
      throttleText = clamp(ThrottlePos,-100,100)
      throttleText = format("%.0f", throttleText*100).."％"
     else 
      throttleText = clamp(ThrottlePos,-unitData.maxSpeedkph,unitData.maxSpeedkph)
      throttleText = format("%.0f", throttleText).." km/h"
     end
     local xyzSpeedText = format("%.0f", xyzSpeedKPH).." km/h"
     if xyzSpeedKPH > 50000 then xyzSpeedText = "FTL" end
     local throttleClipY = 0
     local tPos = 0
     if MM == "TRAVEL" then
      tPos = clamp(ThrottlePos,-1,1)
      throttleClipY = 700 - 400 * floor(abs(tPos)*100)/100
     else tPos = clamp(ThrottlePos,-unitData.maxSpeedkph,unitData.maxSpeedkph)
      throttleClipY = 700 - 400 * abs(tPos)/unitData.maxSpeedkph
     end
     local currentThrust = 0
     if inspace == 0 then currentThrust = unitData.atmoThrust
     else currentThrust = unitData.spaceThrust
     end
     local forwardEnginesForce = Nav:maxForceForward()

     -- Brake Distance Hud
     local fBD, bBD = brakingCalculation()
     if fBD == nil then fBD = 0 
     elseif fBD < 1000 then
      fBD = format("%.0f", fBD).."m"
     elseif fBD > 1000 then 
      fBD = format("%.1f", fBD/1000).."km"
     elseif fBD > 50000 then 
      fBD = format("%.2f",fBD/200000).."su"
     end

     --Flight Mode/SubMode
     --local fM = string.sub(MM,1,1)
     local fM = ""
     if parkingEligible() then
      local fMMs, fPMs = "",""
      if pkM then 
       fMMs = [[class="strike"]]
       fPMs = [[class="bold"]]
      else
       fMMs = [[class="bold"]]
       fPMs = [[class="strike"]]
      end
      fM = [[<text x="1400" y="690" font-size="20" ]]..fMMs..[[ text-anchor="start"]]..temp1..P.KP.flM.value..[[</text>
      
      <text x="1420" y="710" font-size="14" ]]..fPMs..[[ text-anchor="start"]]..temp1..P.KP.pkM.value..[[</text>]]
     else
      fM = [[<text x="1400" y="700" font-size="20" text-anchor="start"]]..temp1..MM..[[</text>]]
     end

     local altLock = ""
     if HoldAltitude then 
      altLock = [[<text x="1325" y="550" font-size="12" text-anchor="middle" font-family="]]..widget_font..[[" alignment-baseline="middle" stroke-width="0" fill="red">Alt locked: ]]..HoldAltitude..[[</text>]]
     end

     local brakeClipY = 200 * unitData.currentBrake/unitData.maxBrake
     local accelClipY = 500 - 200 * currentThrust/forwardEnginesForce
     local SVGspeedo = [[
      <clipPath id="clipthrottle">
      <rect x="800" y="]]..throttleClipY..[[" width="800" height="]].. 700 - throttleClipY..[[" />
      </clipPath>
      
      <clipPath id="clipbrake">
      <rect x="0" y="500" width="800" height="]]..brakeClipY..[[" />
      </clipPath>
      
      <clipPath id="clipaccel">
      <rect x="0" y="]]..accelClipY..[[" width="800" height="]].. 500 - accelClipY..[[" />
      </clipPath>
      
      <text x="1325" y="500" font-size="20" text-anchor="middle"]]..temp1..xyzSpeedText..[[</text>
      <text x="1425" y="500" font-size="15" text-anchor="start"]]..temp1..throttleText..[[</text>
      ]]..altLock..[[
      
      <text x="170" y="500" font-size="15" text-anchor="end"]]..temp1..format("%.0f", abs(zSpeedKPH))*sign(zSpeedKPH).." km/h"..[[</text>
      
      ]]..fM..[[
      <text x="1395" y="300" font-size="15" text-anchor="start"]]..temp1..fBD..[[</text>

      <circle cx="800" cy="500" r="610" stroke-width="20" stroke="]]..WAC..[[" fill="none" stroke-opacity="]].. 0.25 ..[[" clip-path="url(#clipthrottle)"/>
      
      <circle cx="800" cy="500" r="610" stroke-width="20" stroke="]]..WAC..[[" fill="none" stroke-opacity="]].. 0.25 ..[[" clip-path="url(#clipbrake)"/>
      <text x="205" y="700" font-size="12" text-anchor="end"]]..temp1..format("%.0f", unitData.currentBrake/1000).." / "..format("%.0f", unitData.maxBrake/1000).."kn"..[[</text>
     
      <circle cx="800" cy="500" r="610" stroke-width="20" stroke="]]..WAC..[[" fill="none" stroke-opacity="]].. 0.25 ..[[" clip-path="url(#clipaccel)"/>
      <text x="205" y="300" font-size="12" text-anchor="end"]]..temp1..format("%.0f", currentThrust/1000).." / "..format("%.0f", forwardEnginesForce/1000).."kn"..[[</text>
     ]]
     local b10,b11 = [[<use xlink:href="]],[[" transform="rotate(]]
     local b20,b21 = b10.."#bankthick"..b11,b10.."#bankthin"..b11
     local SVGbank = [[
      <clipPath id="clipbankcircle400">
      <rect x="0" y="300" width="1600" height="400"/>
      </clipPath>
      <circle cx="800" cy="500" r="400" stroke-width="5" stroke="]]..WFC..[[" fill="none" clip-path="url(#clipbankcircle400)" transform="rotate(]]..Ay0..[[ 800 500)"/>
      <polygon id="triangle400" points="400 500, 402 505, 412 500, 402 495" stroke-width="0" fill="]]..WFC..[[" transform="rotate(]]..Ay0..[[ 800 500)"/>
      <use xlink:href="#triangle400" transform="rotate(180 800 500)"/>
      
      <line id="bankthick" x1="800" y1="97.5" x2="800" y2= "102.5" stroke-width="5" stroke="]]..WFC..[["/>
      ]]..b20..[[10 800 500)"/>
      ]]..b20..[[20 800 500)"/>
      ]]..b20..[[30 800 500)"/>
      
      ]]..b20..[[-10 800 500)"/>
      ]]..b20..[[-20 800 500)"/>
      ]]..b20..[[-30 800 500)"/>
      
      <polygon id="banktriangle" points="800 97.5, 807 87.5, 793 87.5" stroke-width="0" fill="]]..WFC..[[" transform="rotate(]]..Ay0..[[ 800 500)"/>
      <use xlink:href="#banktriangle" transform="rotate(180 800 500)"/>
      
      <line id="bankthin" x1="800" y1="100" x2="800" y2= "102.5" stroke-width="1" stroke="]]..WFC..[["/>
      ]]..b21..[[2.5 800 500)"/>
      ]]..b21..[[5 800 500)"/>
      ]]..b21..[[7.5 800 500)"/>
      ]]..b21..[[12.5 800 500)"/>
      ]]..b21..[[15 800 500)"/>
      ]]..b21..[[17.5 800 500)"/>
      ]]..b21..[[22.5 800 500)"/>
      ]]..b21..[[25 800 500)"/>
      ]]..b21..[[27.5 800 500)"/>
    
      ]]..b21..[[-2.5 800 500)"/>
      ]]..b21..[[-5 800 500)"/>
      ]]..b21..[[-7.5 800 500)"/>
      ]]..b21..[[-12.5 800 500)"/>
      ]]..b21..[[-15 800 500)"/>
      ]]..b21..[[-17.5 800 500)"/>
      ]]..b21..[[-22.5 800 500)"/>
      ]]..b21..[[-25 800 500)"/>
      ]]..b21..[[-27.5 800 500)"/>
      
      <text x="800" y="70" font-size="12" transform="rotate(]]..Ay0..[[ 800 500)" text-anchor="middle"]]..temp1..format("%.0f", abs(Ay0))*utils.sign(Ay0).."°"..[[</text>
     ]]     

     local AHT = sign(Ax0) * abs(Ax0) / 90 * 400
     local SVGpitchbars = ""
     local i = 1
     local j = 800/18
     if alt < P.AS.stA.value then
      local temp2 = [[" font-size="12" text-anchor="middle" alignment-baseline="middle" stroke-width="0" >]]
      while (i<19) do
       if i*10 < Ax0 + 50 then
       SVGpitchbars = SVGpitchbars ..[[
       <line x1="0" y1="]].. 500 - i*j ..[[" x2="450" y2= "]].. 500 - i*j ..[[" stroke-width="]].. 2*(1-i/19) ..[[" fill="none"/>
       <text x="465" y="]].. 500 - i*j ..temp2.. i*10 ..[[</text>
       <line x1="1600" y1="]].. 500 - i*j ..[[" x2="1150" y2= "]].. 500 - i*j ..[[" stroke-width="]].. 2*(1-i/19) ..[[" fill="none"/>
       <text x="1135" y="]].. 500 - i*j ..temp2.. i*10 ..[[</text>
       ]]
       end
       if i*-10 > Ax0 - 50 then
       SVGpitchbars = SVGpitchbars ..[[
       <line x1="1600" y1="]].. 500 + i*j ..[[" x2="1150" y2= "]].. 500 + i*j ..[[" stroke-width="]].. 2*(1-i/19) ..[[" fill="none"/>
       <text x="1135" y="]].. 500 + i*j ..temp2.. i*-10 ..[[</text>
       <line x1="0" y1="]].. 500 + i*j ..[[" x2="450" y2= "]].. 500 + i*j ..[[" stroke-width="]].. 2*(1-i/19) ..[[" fill="none"/>
       <text x="465" y="]].. 500 + i*j ..temp2.. i*-10 ..[[</text>
       ]]
       end
       i = i+1
      end
      SVGpitchbars = SVGpitchbars..[[
       <line x1="0" y1="500" x2="450" y2= "500" stroke-width="3" fill="none"/>
       <text x="465" y="500]]..temp2..[[0</text>
       <line x1="1600" y1="500" x2="1150" y2= "500" stroke-width="3" fill="none"/>
       <text x="1135" y="500]]..temp2..[[0</text>
       <line x1="480" y1="500" x2="700" y2= "500" stroke-width="2" />
       <line x1="1120" y1="500" x2="900" y2= "500" stroke-width="2" />
      ]]
     end
     local SVGpitch = [[
      <clipPath id="clippitchcircle400">
      <circle cx="800" cy="500" r="400"/>
      </clipPath>
      
      <g clip-path="url(#clippitchcircle400)" stroke="]]..WFC..[[" font-family="]]..widget_font..[[" fill="]]..WFC..[[" stroke-opacity="]].. 0.25 ..[[" fill-opacity="]].. 0.5 ..[[">
        <g transform="rotate(]]..Ay0..[[ 800 500) translate(0 ]]..AHT..[[)">
      ]]..SVGpitchbars..[[
      </g></g>
      
      <text x="380" y="500" font-size="12" transform="rotate(]]..Ay0..[[ 800 500)" text-anchor="middle"]]..temp1..format("%.0f", abs(Ax0))*utils.sign(Ax0).."°"..[[</text>
     ]]
     local cAV = construct.getAbsoluteVelocity()
     local cAVx, cAVy, cAVz = normalizeVec(xSpeedKPH * 0.27777777777, ySpeedKPH * 0.27777777777, zSpeedKPH * 0.27777777777)
     local velStrokeColor = WFC
     if xyzSpeedKPH < 5 then cAVx, cAVy, cAVz = 0,0,0 else if abs(Ax) > 45 or abs(Az) > 45 then velStrokeColor = "red" end end
     local SVGvelocity = [[
     <circle cx="]].. 800+cAVx*400 ..[[" cy="]].. 500+cAVz*-400 ..[[" r="10" stroke-width="1.5" stroke="]]..velStrokeColor..[[" fill="none"/>
     <line x1="800" y1="500" x2="]].. 800+cAVx*400 ..[[" y2= "]].. 500+cAVz*-400 ..[[" stroke-width="1" fill="none" stroke="]]..velStrokeColor..[["/>
     ]]
     
     local SVGfuel = ""
     local left = 0
     for i , v in ipairs(fuelTanksData) do
      
      local fuelT = tonumber(fuelTanksData[i].timeLeft)
      local fuelTLeft = fuelT==nil and "N/A" or fuelT>1000000 and "inf" or format("%.0f", fuelT/60) .. " min" or "N/A"
      local fuelPLeft = format("%.0f", fuelTanksData[i].percentage) .. "％"
      SVGfuelText[i] =  fuelTLeft .. " ( ".. fuelPLeft .." )"
      if string.sub(fuelTanksData[i].name,-1,-1) ~= "L" then
       SVGfuel = SVGfuel..[[
       <text x="1350" y="]].. 740+(i-1-left)*20 ..[[" font-size="12" text-anchor="end" font-family="]]..widget_font..[[" alignment-baseline="middle" stroke-width="0" fill="]]..WFC..[[" >]]..string.sub(fuelTanksData[i].name,1,7):upper()..[[</text>
       
       <rect x="1360" y="]].. 732+(i-1-left)*20 ..[[" width="]].. 150*tonumber(fuelTanksData[i].percentage)/100 ..[[" height="15" stroke-width="1" fill="]]..WFC..[[" stroke="none" fill-opacity="]].. 0.25 ..[["/>
       <rect x="1360" y="]].. 732+(i-1-left)*20 ..[[" width="150" height="15" stroke-width="1" stroke="]]..WFC..[[" fill="none" />
       
       <text x="1445" y="]].. 740+(i-1-left)*20 ..[[" font-size="12" text-anchor="middle"]]..temp1..SVGfuelText[i]..[[</text>
       ]]
      else
       SVGfuel = SVGfuel..[[
       <text x="245" y="]].. 740+(i-1)*20 ..[[" font-size="12" text-anchor="start" font-family="]]..widget_font..[[" alignment-baseline="middle" stroke-width="0" fill="]]..WFC..[[" >]]..string.sub(fuelTanksData[i].name,1,7):upper()..[[</text>
       
       <rect x="90" y="]].. 732+(i-1)*20 ..[[" width="]].. 150*tonumber(fuelTanksData[i].percentage)/100 ..[[" height="15" stroke-width="1" fill="]]..WFC..[[" stroke="none" fill-opacity="]].. 0.25 ..[["/>
       <rect x="90" y="]].. 732+(i-1)*20 ..[[" width="150" height="15" stroke-width="1" stroke="]]..WFC..[[" fill="none" />
       
       <text x="175" y="]].. 740+(i-1)*20 ..[[" font-size="12" text-anchor="middle"]]..temp1..SVGfuelText[i]..[[</text>
       ]]
       left = left + 1
      end
     end
     SVGfinal = '<div><svg viewBox="0 0 '.. self.hudSVGSize.x ..' '.. self.hudSVGSize.y ..'">'..SVGrecindicator..SVGaltitude..SVGbank..SVGspeedo..SVGfixed..SVGpitch..SVGvelocity..SVGfuel..'</svg></div>'
     return SVGfinal
    end
    -- Info Widget --
    function WidgetsPlusPlus.Info_Update(self)
     local WFC = P.MS.WFC.value
     local WTC = P.MS.wTC.value
     local WAC = P.MS.wAC.value
     local WC = P.MS.WC.value
     local WCA = P.MS.WCA.value
     local fontSize = 15
     local lineSpace = 25
     info_window_height = 0

     local fBD, bBD = brakingCalculation()
     if fBD == nil then fBD = 0 
     elseif fBD < 1000 then
      fBD = format("%.0f",fBD).."m"
     elseif fBD > 1000 then 
      fBD = format("%.0f",fBD/1000).."km"
     elseif fBD > 50000 then 
      fBD = format("%.2f",fBD/200000).."su"
     end

     if bBD == nil then bBD = 0
     elseif bBD < 1000 then
      bBD = format("%.0f",bBD).."m"
     elseif bBD > 1000 then 
      bBD = format("%.0f",bBD/1000).."km"
     elseif bBD > 50000 then 
      bBD = format("%.2f",bBD/200000).."su"
     end

     local t1, t2 = [[<tspan x="5" dy="]],[[" text-anchor="start" fill="]]..WFC..[[">]]
     local tmp1 = t1..lineSpace..t2
     local tmp2 = [[</tspan><tspan x="300" dy="0" text-anchor="end" fill="]]..WTC..[[">]]
     local KeybindsSVG = [[
      <tspan x="5" text-anchor="start" fill="]]..WFC..[[">]]..'KEYBINDS:'..tmp2..''..[[</tspan>
      ]]..tmp1..'Main Menu: '..tmp2..'Alt + 1'..[[</tspan>
      ]]..tmp1..'Quck Menu: '..tmp2..'Alt + Alt Hold'..[[</tspan>
      ]]..tmp1..'AutoLand: '..tmp2..'G'..[[</tspan>
      ]]..tmp1..'Alt Lock at 11％ atmo: '..tmp2..P.KP.altitudeAP.value..[[</tspan>
      ]]..tmp1..'Reset Databank: lua channel '..tmp2..'reset all'..[[</tspan>
     ]]
     info_window_height = 6 * 30

     local InfoUnitSVG = [[
      ]]..t1..lineSpace*2 ..t2..'W.POS: '..tmp2.. format("%.0f",currentWorldPos.x) ..":"..format("%.0f",currentWorldPos.y) ..":"..format("%.0f",currentWorldPos.z) ..[[</tspan>
      ]]..tmp1..'CLOSEST PLANET: '..tmp2..currentPlanetName..[[</tspan>
      ]]..tmp1..'ALTITUDE: '..tmp2..format("%.1f",alt/1000).."km"..[[</tspan>
      ]]..tmp1..'FLIGHT MODE: '..tmp2..MM .." MODE"..[[</tspan>
      ]]..tmp1..'OPTIMAL ORBITAL SPEED: '..tmp2..format("%.0f",math.sqrt(currentPlanetGM / (alt + currentPlanetRadius))*3.6).."kmph"..[[</tspan>
      ]]..tmp1..'MAX SPEED: '..tmp2..format("%.0f",unitData.maxSpeedkph).."kph"..[[</tspan>
      ]]..tmp1..'ACCELERATION: '..tmp2..format("%.4f",unitData.acceleration/10).."g"..[[</tspan>
      ]]..tmp1..'MAX BRAKE: '..tmp2..format("%.0f",unitData.maxBrake/1000).."kn"..[[</tspan>
      ]]..tmp1..'FORWARD BRAKE DISTANCE: '..tmp2..fBD..[[</tspan>
      ]]..tmp1..'BACKWARD BRAKE DISTANCE: '..tmp2..bBD..[[</tspan>
      ]]..tmp1..'ATMO TRHUST: '..tmp2..format("%.0f",unitData.atmoThrust/1000).."kn"..[[</tspan>
      ]]..tmp1..'SPACE TRHUST: '..tmp2..format("%.0f",unitData.spaceThrust/1000).."kn"..[[</tspan>
      ]]..tmp1..'CONSTRUCT WEIGHT: '..tmp2..format("%.2f",coreMass/1000).."tons"..[[</tspan>
      ]]..tmp1..'FPS: '..tmp2..format("%.0f",fps).."fps"..[[</tspan>
     ]]
     info_window_height = info_window_height + 12 * 30

     local InfoAGGSVG = ""
     if self.antigrav ~= nil then 
      InfoAGGSVG = [[
       ]]..t1..lineSpace*2 ..t2..'ANTIGRAVITY STATE: '..tmp2..tostring(aggData.State):upper()..[[</tspan>
       ]]..tmp1..'POWER: '..tmp2..tostring(aggData.Power):upper()..[[</tspan>
       ]]..tmp1..'FIELD: '..tmp2..tostring(aggData.Field):upper()..[[</tspan>
       ]]..tmp1..'CURRENT ALTITUDE: '..tmp2..tostring(aggData.Altitude):upper().."m"..[[</tspan>
       ]]..tmp1..'SETUP ALTITUDE: '..tmp2..tostring(P.ES.agA.value):upper().."m"..[[</tspan>
      ]]
      info_window_height = info_window_height + 6 * 30
     end

     local InfoWarpSVG = ""
     if self.warpdrive ~= nil then
      InfoWarpSVG = [[
       ]]..t1..lineSpace*2 ..t2..'WARP INFO: '..tmp2..tostring(warpData.Info):upper()..[[</tspan>
       ]]..tmp1..'CELLS COUNT: '..tmp2..tostring(warpData.Cells):upper()..[[</tspan>
       ]]..tmp1..'DESTINATION: '..tmp2..tostring(warpData.Destination):upper()..[[</tspan>
       ]]..tmp1..'DISTANCE: '..tmp2..format("%.1f",warpData.Distance/200000).." su"..[[</tspan>
      ]]
      info_window_height = info_window_height + 5 * 30
     end
     local InfoSVG = '<div><svg viewBox="0 0 309 '..info_window_height..'"><text x="5" y="20" font-size="'..fontSize..'" font-family="'..widget_font..'">'..KeybindsSVG..InfoUnitSVG..InfoAGGSVG..InfoWarpSVG..'</text></svg></div>'
     
     return InfoSVG
    end
    function WidgetsPlusPlus.Platform_Update(self)
     local wTC = P.MS.wTC.value --widget text color
     local wAC = P.MS.wAC.value --widget animated color
     local WFC = P.MS.WFC.value --widget fixed color
     local fSW = 1.5 --fixed stroke width
     local op = 0.95 -- opacity
 
     local SVGfuel = ""
     for i , v in ipairs(fuelTanksData) do
      if i > 4 then break end --no more than 4 fuel tanks displayed
      local fuelT = tonumber(fuelTanksData[i].timeLeft)
      local fuelTLeft = fuelT==nil and "N/A" or fuelT>1000000 and "inf" or format("%.0f", fuelT/60) .. " min" or "N/A"
      local fuelPLeft = format("%.0f", fuelTanksData[i].percentage) .. "％"
      SVGfuelText[i] =  fuelTLeft .. " ( ".. fuelPLeft .." )"
      SVGfuel = SVGfuel..[[
      <rect x="125" y="]].. 85+(i-1)*-12 ..[[" width="]].. 69*tonumber(fuelTanksData[i].percentage)/100 ..[[" height="9" stroke-width="1" fill="]]..wAC..[[" stroke="none" fill-opacity="]].. 0.25 ..[["/>
      <rect x="125" y="]].. 85+(i-1)*-12 ..[[" width="69" height="9" stroke-width="]]..fSW..[[" stroke="]]..WFC..[[" fill="none" />
      <text x="160" y="]].. 90+(i-1)*-12 ..[[" font-size="6" text-anchor="middle" font-family="]]..widget_font..[[" alignment-baseline="middle" stroke-width="0" fill="]]..wTC..[[" >]]..SVGfuelText[i]..[[</text>
      ]]
     end
 
     --glass frame brackground
     local SVG_glassframe = [[
      <defs>
       <linearGradient id="grad1" x1="0" y1="0" x2="0.5" y2="0.75">
       <stop offset="0.8" style="stop-color:grey;stop-opacity:0.15" />
       <stop offset="1.2" style="stop-color:white;stop-opacity:0.1" />
       </linearGradient>
       <linearGradient id="grad2" x1="0" y1="0" x2="1" y2="1">
       <stop offset="0.1" style="stop-color:white  ;stop-opacity:0.75" />
       <stop offset="0.9" style="stop-color:grey;stop-opacity:0.5" />
       </linearGradient>
      </defs>
      <rect x="2" y="2" rx="8" ry="8" width="200" height="100" fill="url(#grad1)" stroke="none" fill-opacity="0.15" />
      <rect x="2" y="2" rx="8" ry="8" width="200" height="100" fill="none" stroke="url(#grad2)" stroke-width="2" stroke-opacity="0.5"/>
     ]]
 
     --vertical velocity bar
     local zVY = clamp(planetVertSpeedMPS*-0.3,-42,42) 
     local SVG_Zvel_fix = [[
      <rect x="10" y="10" width="15" height="84" style=" fill:none;stroke:]]..WFC..[[;stroke-width:]]..fSW..[["/>
     ]]
     local SVG_Zvel_anim = [[
      <polyline points="10,52 10,]]..format("%.1f",52+zVY)..[[ 25,]]..format("%.1f",52+zVY)..[[ 25,52" style="fill:]]..wAC..[[";stroke:"none" fill-opacity="0.25"/>
     ]]
 
     -- XY velocity graphic
     local xSMPS = dotVec(cWAVx, cWAVy, cWAVz, normalizeVec(cWORx, cWORy, cWORz))
     local ySMPS = dotVec(cWAVx, cWAVy, cWAVz, normalizeVec(cWOFx, cWOFy, cWOFz))

     local xVx = xSMPS and clamp(xSMPS*0.3,-38,38) or 0
     local yVy = ySMPS and clamp(ySMPS*-0.3,-38,38) or 0
     local SVG_XYvel_anim = [[<g style="stroke-linecap: round; stroke-linejoin: round;" fill="none" stroke="]]..wAC..[[" stroke-width="]]..fSW..[[">
      <line x1="75" y1="52" x2="]]..format("%.1f",75+xVx)..[[" y2="]]..format("%.1f",52+yVy)..[["/>
      <rect x="]]..format("%.1f",72+xVx)..[[" y="]]..format("%.1f",49+yVy)..[[" width="6" height="6"/>
     </g>]]
         
     local SVG_XYvel_fix = [[<g fill="none" style="stroke: ]]..WFC..[[; stroke-linecap: round; stroke-linejoin: round;" stroke-width="]]..fSW..[[">
      <polyline points="33,38 33,10 61,10"/>
      <polyline points="89,10 117,10 117,38"/>
      <polyline points="117,66 117,94 89,94"/>
      <polyline points="61,94 33,94 33,66"/>
      <rect x="70" y="47" width="10" height="10"/>
     </g>]]
 
     --animated text
     local gndH = abvGndDet > 0 and floor(round(abvGndDet)).."m" or " N/A"
     local SVG_text_anim = [[<g text-anchor="end" font-family="]]..widget_font..[[" alignment-baseline="bottom" stroke-width="0" fill="]]..wAC..[[">
      <text x="170" y="25" font-size="21">]]..floor(round(xyzSpeedKPH))..[[</text>
      <text x="195" y="17.5" font-size="10">km/h</text>
     </g>
     <g font-size="7" text-anchor="start" font-family="]]..widget_font..[[" alignment-baseline="bottom" stroke-width="0" fill="]]..wAC..[[">
      <text x="125" y="35" >alt:]]..floor(round(alt))..[[</text>
      <text x="164" y="35" >tel:]]..gndH..[[</text>
     </g>]]
 
     local viewBox = 'viewBox="0 0 '.. self.platSVGSize.x ..' '.. self.platSVGSize.y ..'"'
     local svgBottom = SVGfuel..SVG_Zvel_fix..SVG_XYvel_fix..SVG_XYvel_anim..SVG_text_anim
     local svgTop = SVG_glassframe..SVG_Zvel_anim
     local SVGfinal = '<div><svg '..viewBox..' style="position:absolute; filter: drop-shadow(2px 2px 3px black);">'..svgBottom..'</svg><svg '..viewBox..' style="position:absolute;">'..svgTop..'</svg></div>'
     return SVGfinal
    end
  onStart:
   lua: |
    --minified winlib--.lua
    WLP = {}
    WLP.__index = WLP
    local DWN_Position_X = 0
    local DWN_Position_Y = 0
    local DWN_Width = 300
    local DWN_Height = 150
    local DWN_TitleBar_Height = 25
    local DBu_Position_X = 0
    local DBu_Position_Y = 0
    local DBu_Width = 96
    local DBu_Height = 24
    
    
    WLP.css = {}
    WLP.buttonsNew = {}
    
    function WLP.init()
     local self = setmetatable({}, WLP)
     self.index = 0
     self.windows = {}
     self.buttonLock = nil
     self.wlib_drag = false
     self.CLICK = false
     self.mouseWheel = 0
     self.previousGenerated = ""
     return self
    end
    
    function WLP.winlibCSSUpdate(self)
     local WC = P.MS.WC.value
     local WCA = P.MS.WCA.value
     local WTC = P.MS.WTC.value
     local TCA = P.MS.TCA.value
     local TTC = P.MS.TTC.value
     local BCA = P.MS.BCA.value
     local BTC = P.MS.BTC.value
     local wTC = P.MS.wTC.value
     local wAC = P.MS.wAC.value
     local titleR, titleG, titleB = webColors.namedColor2RGB(P.MS.TC.value)
     local titleRGB = tostring(titleR)..","..tostring(titleG)..","..tostring(titleB)
     local windowR, windowG, windowB = webColors.namedColor2RGB(WC)
     local windowRGB = tostring(windowR)..","..tostring(windowG)..","..tostring(windowB)
     local buttonR, buttonG, buttonB = webColors.namedColor2RGB(P.MS.BC.value)
     local buttonRGB = tostring(buttonR)..","..tostring(buttonG)..","..tostring(buttonB)
     local buttonborderR, buttonborderG, buttonborderB = webColors.namedColor2RGB(P.MS.BBC.value)
     local buttonborderRGB = tostring(buttonborderR)..","..tostring(buttonborderG)..","..tostring(buttonborderB)
    
     self.css.base = [[
      BODY {
       background:rgba(0, 0, 0, 0);
       color:#000000;
       width:100vw;
       height:100vh;
      }
      DIV.WinLib_window {
       position:absolute;
       background:rgba(]]..windowRGB..[[, ]]..WCA..[[);
       color:]]..WTC..[[;
       font-family:"Arial", Sans-Serif;
       box-shadow:0px 1px rgba(128, 128, 128, 0.5);
       font-size:15px;
       text-align:middle;
       fill:]]..WTC..[[;
      }
      DIV.WinLib_w_title {
       height:20px;
       background-color: rgba(]]..titleRGB..[[, ]]..TCA..[[);
       background-image: white;
       color:]]..TTC..[[;
       font-size:16px;
       text-align:center;
       padding-left:4px;
       font-family:"Bank";
      }
      DIV.WinLib_window>.WinLib_content {
       padding:4px;
       color:]]..WTC..[[;
       fill:]]..WTC..[[;
      }
      DIV.WinLib_button {
       position:absolute;
       background: rgba(]]..buttonRGB..[[, ]]..BCA..[[);
       border:1px solid rgb(]]..buttonborderRGB..[[);
       font-family:"Play";
       font-size:12px;
       text-align: center;
       vertical-align: text-top;
       color:]]..BTC..[[;
       overflow:hidden;
       padding-top:5px;
      }
      .widgets {
       background:rgba(0, 0, 0, 0) !important;
       box-shadow:0px 0px rgba(0, 0, 0, 0) !important;
      }
      .widgetnopadding {
       padding: 0px !important;
       padding-top: 0px !important;
       padding-left: 0px !important;
      }
      .separator {
       background:rgba(0, 0, 0, 0) !important;
       border:0px solid rgba(0, 0, 0, 0) !important;
       font-size:0px !important;
       color:rgba(0, 0, 0, 0) !important;
       box-shadow:0px 0px rgba(0, 0, 0, 0) !important;
       border: 0px solid rgba(0, 0, 0, 0) !important;
      }
      .Help_Menu {
       font-family:"Play" !important;
       font-size:14px !important;
      }
      .buttonHover {
       position:absolute;
       border: 3px solid rgb(]]..buttonborderRGB..[[) !important;
       font-family:"Play" !important;
       font-size:13px !important;
       text-align: center !important;
       vertical-align: text-top !important;
       box-shadow:3px 2px rgba(50, 50, 50, 0.5) !important;
       color:]]..BTC..[[ !important;
       overflow:hidden !important;
       padding-top:2px !important;
      }
      .fixed {
       z-index:1 !important;
      }
      .strike {
       text-decoration:line-through underline;
       opacity: 0.3;
      }
      .bold {
       font-family:"Play" !important;
       font-weight:bold;
      }
      .demo {
      text-align:center;
      }
      ]]
    end
    --WLP.winlibCSSUpdate()
    
    WLP.css.w_block = [[
    
     #{wlib_id} {
      width:{wlib_width}px;
      height:{wlib_height}px;
      top:{wlib_posY}px;
      left:{wlib_posX}px;
      z-index:{wlib_zIndex};
     }
     #{wlib_id}>.WinLib_w_title {
      height:{wlib_title_height}px;
      line-height:{wlib_title_height}px;
     }
     {wlib_buttons_generated}]]
    WLP.css.button_block = [[
    
     #{wlib_id} {
      width:{wlib_width}px;
      height:{wlib_height}px;
      top:{wlib_posY}px;
      left:{wlib_posX}px;
     }]]
    WLP.css.generated_block = [[
     <style>
    {wlib_css_generated}
     </style>
    ]]
    
    -- WLP HTML
    WLP.html = {}
    WLP.html.base = [[
    
    <style type="text/css">
    {wlib_css}
    {wlib_css_generated}
    </style>
    {wlib_html_generated}
    ]]
    WLP.html.window = [[
    <DIV class="WinLib_window {wlib_custom_class}" id="{wlib_id}">
    {wlib_title_bar}
     <DIV class="WinLib_content">
    {wlib_html}
    {wlib_buttons_generated}
     </DIV>
    </DIV>]]
    WLP.html.w_title = [[
     <DIV class="WinLib_w_title" id="title_bar">
      {wlib_title}
     </DIV>]]
    WLP.html.button = [[
     <DIV class="WinLib_button {wlib_custom_class}" id="{wlib_id}">
      {wlib_html}
     </DIV>]]

    function WLP.new(self,html,options,buttons)
     local window = {} 
     window.name = nil
     window.title = nil
     window.class = nil
     window.posX = DWN_Position_X
     window.posY = DWN_Position_Y
     window.width = DWN_Width
     window.height = DWN_Height
     window.titleHeight = DWN_TitleBar_Height
     window.draggable = false
     window.alwaysOnTop = false
     window.fixed = false
     if options ~= nil then
      window.name = (options.name ~= nil) and options.name or window.name
      window.title = (options.title ~= nil) and options.title or window.title
      window.class = (options.class ~= nil) and options.class or window.class
      window.posX = (options.posX ~= nil) and options.posX or window.posX
      window.posY = (options.posY ~= nil) and options.posY or window.posY
      window.width = (options.width ~= nil) and options.width or window.width
      window.height  = (options.height ~= nil) and options.height or window.height
      window.titleHeight = (options.titleHeight ~= nil) and options.titleHeight or window.titleHeight
      if options.draggable == nil or options.draggable == true then window.draggable = true else window.draggable = false end
      if options.alwaysOnTop == nil or options.alwaysOnTop == false then window.alwaysOnTop = false else window.alwaysOnTop = true end
      if options.fixed == nil or options.fixed == false then window.fixed = false else window.fixed = true end
     end

     window.buttons = (buttons == nil) and {} or buttons

     self.index = self.index + 1 -- Global index increment
     window.id = "wlib_w_" .. self.index -- Unique ID
     window.html = (html == nil) and "" or html -- Content provided by the user

     if window.fixed == true then
      window.zIndex = -100
     else
      window.zIndex = (window.alwaysOnTop == true) and 999999 + self.index or self.index
     end

     window.css = ""
     window.content = ""

     window.refresh = function()
      local button_html = ""
      local button_css  = ""

      for i, button in pairs(window.buttons) do
       button:refresh()
       button_html = button_html .. button.content
       button_css = button_css .. button.css
      end

      window.css = self.css.w_block
       :gsub("{wlib_id}",window.id)
       :gsub("{wlib_width}",window.width)
       :gsub("{wlib_height}",window.height)
       :gsub("{wlib_posX}",window.posX)
       :gsub("{wlib_posY}",window.posY)
       :gsub("{wlib_zIndex}",window.zIndex)
       :gsub("{wlib_title_height}",window.titleHeight)
       :gsub("{wlib_buttons_generated}",button_css)
    
      local title_bar = (window.title == nil) and "" or self.html.w_title
       :gsub("{wlib_title}",window.title)
      local custom_class = (window.class == nil) and "" or window.class
      window.content = self.html.window
       :gsub("{wlib_id}",window.id)
       :gsub("{wlib_custom_class}",custom_class)
       :gsub("{wlib_title_bar}",title_bar)
       :gsub("{wlib_html}",window.html)
       :gsub("{wlib_buttons_generated}",button_html)
     end

     window.setHTML = function(content)
      window.html = content
     end

     window.setTitle = function(content)
      window.title = content
     end

     window.setPos = function(x,y)
      window.posX = x
      window.posY = y
     end

     window.delete = function()
      self.windows[window.id] = nil
     end

     self.windows[window.id] = window
     return window
    end

    function WLP.toggleClick(self,bool)
     self.CLICK = bool
    end

    function WLP.update(self)
     self:mouseListener()
     if P.w_open == false then
      for k1, window in pairs(self.windows) do
       if P.Widget_HUD.w_open == true and window.name == P.Widget_HUD.w_title then
        if widget:HUD_Update() then window.setHTML(widget:HUD_Update()) else window.setHTML("") end
       end
       if P.Widget_Info.w_open == true and window.name == P.Widget_Info.w_title then
        if widget:Info_Update() then window.setHTML(widget:Info_Update()) else window.setHTML("") end
       end
       if P.Widget_Platform.w_open == true and window.name == P.Widget_Platform.w_title then
        if widget:Platform_Update() then window.setHTML(widget:Platform_Update()) else window.setHTML("") end
       end
       for i, v in ipairs(customWidgets) do
        if P["Widget_Custom"..i].w_open == true and window.name == P["Widget_Custom"..i].w_title then
         local custom_widget = customWidgets[i]
         if custom_widget:SVG_Update() then
          window.setHTML(custom_widget:SVG_Update())
          if #custom_widget.buttons > 0 then
           for i2, w_button in ipairs(window.buttons) do
            for ___, custom_button in ipairs(custom_widget.buttons) do
             if window.buttons[i2].name == custom_button.name then
              self.windows[k2].buttons[i2].class = custom_button.class
              self.windows[k2].buttons[i2].posX = custom_button.posX
              self.windows[k2].buttons[i2].posY = custom_button.posY
              self.windows[k2].buttons[i2].width = custom_button.width
              self.windows[k2].buttons[i2].height = custom_button.height
              self.windows[k2].buttons[i2].__click = custom_button.button_function()
              self.windows[k2].buttons[i2].refresh()
             end
            end
           end
          end
         else
          window.setHTML("")
         end
        end
       end
      end
     end
     local gen_css = ""
     local windows = ""
     for _, window in pairs(self.windows) do
      window:refresh()
      gen_css = gen_css .. window.css 
      windows = windows .. window.content
      if window.name == "cursor" then
       window.posX = cursorX
       window.posY = cursorY
      end
     end
     local generated = self.html.base
           :gsub("{wlib_css}",self.css.base)
           :gsub("{wlib_css_generated}",gen_css)
           :gsub("{wlib_html_generated}",windows)
     if self.previousGenerated ~= generated then
      system.setScreen(generated)
     end
     self.previousGenerated = generated
    end

    function WLP.mouseListener(self)
     if P.w_open == true or P.QuickToolBar.w_open == true then
      local mouse = self:getMousePos()
      mouseWheel = system.getMouseWheel()
      if mouseWheel ~= 0 then self.CLICK = true end

      if self.grabbed == nil then 
       for _, window in pairs(self.windows) do
        if window.name ~= "cursor" then
         local bound = { x1 = window.posX, y1 = window.posY,
          x2 = window.posX + window.width, y2 = window.posY + window.height }
         if(mouse.x >= bound.x1 and mouse.y >= bound.y1
           and mouse.x <= bound.x2 and mouse.y <= bound.y2) then
          if(self.grabbed == nil) then
           self.grabbed = window
          else
           if(window.zIndex > self.grabbed.zIndex) then
            self.grabbed = window
           end
          end
         end
        end
       end

       if(self.grabbed ~= nil) then
        self:buttonCheck()
        if self.grabbed.zIndex ~= self.index and self.CLICK ~= false then
         if(self.grabbed.alwaysOnTop ~= true) then
          self.index = self.index + 1
          self.grabbed.zIndex = self.index
         end
        end

        if self.grabbed.draggable == true then
         if(self.grabbed.title == nil) then
          self:beginDrag()
         elseif(mouse.y <= self.grabbed.posY + self.grabbed.titleHeight) then
          self:beginDrag()
         else
          self.grabbed = nil
         end
        else
         self.grabbed = nil
        end
       end
      else
       self.buttonLock = nil
      end
      if mouseWheel ~= 0 then
       self.CLICK = false
      end
     end
    end

    function WLP.beginDrag(self)
      local mouse = self:getMousePos()
      self.grabbed.offset = {x = mouse.x - self.grabbed.posX,
           y = mouse.y - self.grabbed.posY}
     self.wlib_drag = true
    end

    function WLP.performDrag(self)
     if self.CLICK == true and mouseWheel == 0 then
      local mouse = self:getMousePos()
      local new_x = tonumber(string.format("%.2f",mouse.x - self.grabbed.offset.x))
      local new_y = tonumber(string.format("%.2f",mouse.y - self.grabbed.offset.y))
      self.grabbed.posX = (self.grabbed.posX ~= new_x) and new_x or self.grabbed.posX
      self.grabbed.posY = (self.grabbed.posY ~= new_y) and new_y or self.grabbed.posY
      Save_Window_Pos(self.grabbed.name,self.grabbed.posX,self.grabbed.posY)
     elseif mouseWheel ~= 0 then
      for i, v in pairs(P) do
       if string.sub (tostring(i),1,7) == "Widget_" and P[i].w_title == self.grabbed.name then
        P[i].w_scale = P[i].w_scale + 0.05 * mouseWheel
        system.print(P[i].w_title.." widget scale: "..P[i].w_scale)
        self.CLICK = false
        windowsShow()
       end
      end
     else
      self:releaseWindow()
     end
    end

    function WLP.releaseWindow(self)
     self.grabbed = nil
     self.wlib_drag = false
    end

    function WLP.buttonCheck(self)
     for _, button in pairs(self.grabbed.buttons) do
      local mouse = self:getMousePos()
      local bound = { x1 = button.posX + self.grabbed.posX,
          y1 = button.posY + self.grabbed.posY,
          x2 = button.posX + self.grabbed.posX + button.width,
          y2 = button.posY + self.grabbed.posY + button.height }
      if(mouse.x >= bound.x1 and mouse.x <= bound.x2 and
        mouse.y >= bound.y1 and mouse.y <= bound.y2 and
        self.buttonLock ~= button) then
       for k1, window in pairs(self.windows) do
        for i1, wbutton in ipairs(window.buttons) do
         if button.id == wbutton.id and button.class ~= "separator" then
          self.windows[k1].buttons[i1].class = "buttonHover"
         end
        end
       end
       if self.CLICK == true then
        self.buttonLock = button
        button:__click()
        self.CLICK = false
       end
      else
       for k1, window in pairs(self.windows) do
        for i1, wbutton in ipairs(window.buttons) do
         if button.id == wbutton.id and button.class ~= "separator" then
          self.windows[k1].buttons[i1].class = ""
         end
        end
       end
      end
     end
    end

    function WLP.getMousePos(self)
      cursorX = system.getMousePosX()
      cursorY = system.getMousePosY()
     return {x = cursorX,y = cursorY}
    end
    
    function WLP.buttonsNew(self, html, onclick, options)
     local button = {}
     button.name = nil
     button.class = nil
     button.posX = DBu_Position_X
     button.posY = DBu_Position_Y
     button.width = DBu_Width
     button.height = DBu_Height

     if(options ~= nil) then
      button.name = (options.name ~= nil) and options.name or button.name
      button.class = (options.class ~= nil) and options.class or button.class
      button.posX = (options.posX ~= nil) and options.posX or button.posX
      button.posY = (options.posY ~= nil) and options.posY or button.posY
      button.width = (options.width ~= nil) and options.width or button.width
      button.height  = (options.height ~= nil) and options.height or button.height
     end

     self.index = self.index + 1
     button.id = "wlib_button_" .. self.index
     button.html = (html == nil) and "" or html

     button.css = ""
     button.previousCSS = ""
     button.previousContent = ""
     button.refresh = function()

       button.css = self.css.button_block
            :gsub("{wlib_id}",button.id)
            :gsub("{wlib_width}",button.width)
            :gsub("{wlib_height}",button.height)
            :gsub("{wlib_posX}",button.posX)
            :gsub("{wlib_posY}",button.posY)
       local custom_class = (button.class == nil) and "" or button.class
       button.content = self.html.button
            :gsub("{wlib_id}",button.id)
            :gsub("{wlib_custom_class}",custom_class)
            :gsub("{wlib_html}",button.html)
      end
     button.previousCSS = button.css
     button.previousContent = button.content

     button.__click = onclick

     button.setClick = function(clickMethod)
      button.__click = clickMethod
     end

     button.setHTML = function(content)
      button.html = content
     end

     button.setClass = function(content)
      button.class = content
     end
     return button
    end
  onStart:
   lua: |
    -- webcolors
    local function index(t,val)
     for i,v in ipairs(t) do
      if v == val then 
       return i
      end
     end
     return nil
    end
    webColors = {}
    webColors.namedColors = {"aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen"}
    webColors.RGBColors = {{240, 248, 255},{250, 235, 215},{ 0, 255, 255},{127, 255, 212},{240, 255, 255},{245, 245, 220},{255, 228, 196},{ 0, 0, 0},{255, 235, 205},{ 0, 0, 255},{138, 43, 226},{165, 42, 42},{222, 184, 135},{ 95, 158, 160},{127, 255, 0},{210, 105, 30},{255, 127, 80},{100, 149, 237},{255, 248, 220},{220, 20, 60},{ 0, 255, 255},{ 0, 0, 139},{ 0, 139, 139},{184, 134, 11},{169, 169, 169},{ 0, 100, 0},{169, 169, 169},{189, 183, 107},{139, 0, 139},{ 85, 107, 47},{255, 140, 0},{153, 50, 204},{139, 0, 0},{233, 150, 122},{143, 188, 143},{ 72, 61, 139},{ 47, 79, 79},{ 47, 79, 79},{ 0, 206, 209},{148, 0, 211},{255, 20, 147},{ 0, 191, 255},{105, 105, 105},{105, 105, 105},{ 30, 144, 255},{178, 34, 34},{255, 250, 240},{ 34, 139, 34},{255, 0, 255},{220, 220, 220},{248, 248, 255},{255, 215, 0},{218, 165, 32},{128, 128, 128},{128, 128, 128},{ 0, 128, 0},{173, 255, 47},{240, 255, 240},{255, 105, 180},{205, 92, 92},{ 75, 0, 130},{255, 255, 240},{240, 230, 140},{230, 230, 250},{255, 240, 245},{124, 252, 0},{255, 250, 205},{173, 216, 230},{240, 128, 128},{224, 255, 255},{250, 250, 210},{211, 211, 211},{144, 238, 144},{211, 211, 211},{255, 182, 193},{255, 160, 122},{ 32, 178, 170},{135, 206, 250},{119, 136, 153},{119, 136, 153},{176, 196, 222},{255, 255, 224},{ 0, 255, 0},{ 50, 205, 50},{250, 240, 230},{255, 0, 255},{128, 0, 0},{102, 205, 170},{ 0, 0, 205},{186, 85, 211},{147, 112, 219},{ 60, 179, 113},{123, 104, 238},{ 0, 250, 154},{ 72, 209, 204},{199, 21, 133},{ 25, 25, 112},{245, 255, 250},{255, 228, 225},{255, 228, 181},{255, 222, 173},{ 0, 0, 128},{253, 245, 230},{128, 128, 0},{107, 142, 35},{255, 165, 0},{255, 69, 0},{218, 112, 214},{238, 232, 170},{152, 251, 152},{175, 238, 238},{219, 112, 147},{255, 239, 213},{255, 218, 185},{205, 133, 63},{255, 192, 203},{221, 160, 221},{176, 224, 230},{128, 0, 128},{255, 0, 0},{188, 143, 143},{ 65, 105, 225},{139, 69, 19},{250, 128, 114},{244, 164, 96},{ 46, 139, 87},{255, 245, 238},{160, 82, 45},{192, 192, 192},{135, 206, 235},{106, 90, 205},{112, 128, 144},{112, 128, 144},{255, 250, 250},{ 0, 255, 127},{ 70, 130, 180},{ 0, 128, 128},{216, 191, 216},{255, 99, 71},{ 64, 224, 208},{238, 130, 238},{245, 222, 179},{255, 255, 255},{245, 245, 245},{255, 255, 0},{154, 205, 50}}
    function webColors.namedColor2RGB(name)
     if type(name) == "string" then
      local i = index(webColors.namedColors,name)
      return webColors.RGBColors[i][1],webColors.RGBColors[i][2],webColors.RGBColors[i][3]
     end
    end
  onStart:
   lua: |
    -- help menu
    help = {}
    local fontSize = 12
    local lineSpace = 16
    local h1 = '<tspan x="500" dy="'
    local h2 = '</tspan>'
    help.info = [[
     <text x="500" y="30" font-size="]]..fontSize..[[" text-anchor="middle">
      <tspan x="500" font-size="]]..fontSize*2 ..[[">]]..'INSTRUCTION MANUAL'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[" style="font-weight: bold; " font-size="]]..fontSize*1.8 ..[[">]]..'Default -- Flight Script'..h2..[[
      ]]..h1..lineSpace..[[">]]..'The touch screen revolutionary hud and flight script!'..h2..[[
      ]]..h1..lineSpace..[[">]]..'By Jeronimo 2016-2023, minified by TheGreatSardini 2023'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'> "ALT + 1" to open and close Main menu.'..h2..[[
      ]]..h1..lineSpace..[[">]]..'> "LEFT CLICK" as main CLICK.'..h2..[[
      ]]..h1..lineSpace..[[">]]..'> "MOUSE WHEEL STEER" over button to change its VALUE.'..h2..[[
      ]]..h1..lineSpace..[[">]]..'> "LEFT CLICK" over button to change its INCREMENT.'..h2..[[
      ]]..h1..lineSpace..[[">]]..'> "CTRL + LEFT CLICK" to save a button in the QUICK TOOL BAR'..h2..[[
      ]]..h1..lineSpace..[[">]]..'(a little asterisk "*" confirms the shortcut is active).'..h2..[[
      ]]..h1..lineSpace..[[">]]..'> "double tap + hold ALT" to access QUICK TOOL BAR.'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'> All the DEFAULT -- windows and widgets are dragable'..h2..[[
      ]]..h1..lineSpace..[[">]]..'either by their title or background.'..h2..[[
      ]]..h1..lineSpace..[[">]]..'> All the DEFAULT -- widgets are resizeable using mouse wheel'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'> Discord: thegreatsardini'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[" style="font-weight: bold; " font-size="]]..fontSize*1.5 ..[[">]]..'ENJOY!'..h2..[[
     </text>]]
     
    help.menuSettings = [[
     <text x="500" y="30" font-size="]]..fontSize..[[" text-anchor="middle">
      <tspan x="500" font-size="]]..fontSize*2 ..[[">]]..'MENU SETTINGS'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'This MENU is dedicated to windows customization'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- TITLE COLOR: Title bar'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- TITLE ALPHA: Title bar opacity'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- TITLE TEXT COLOR: Title bar'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- WINDOW COLOR: Background color'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- WINDOW ALPHA: Background opacity'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- WINDOW TEXT COLOR: '..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- BUTTON COLOR: Buttons background'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- BUTTON BORDER COLOR: Buttons border'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- BUTTON ALPHA: Buttons background opacity'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- BUTTON TEXT COLOR:'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- WIDGET COLOR: Widgets background'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- WIDGET SVG COLOR1:'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- WIDGET SVG COLOR2:'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- COLOR PRESETS: Up to 5 presets that can be customized at will'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- HELP MENU: Open and close this instructions window'..h2..[[
     </text>]]
     
    help.engineSettings = [[
     <text x="500" y="30" font-size="]]..fontSize..[[" text-anchor="middle">
      <tspan x="500" font-size="]]..fontSize*2 ..[[">]]..'ENGINES SETTINGS'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'This MENU is dedicated to eng default settings'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- PITCH FACTOR: Pitch speed factor parameter'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- YAW FACTOR: Yaw speed factor parameter'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- ROLL FACTOR: Roll speed factor parameter'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- ANGULAR DAMPING: Anti rotational drift factor parameter'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- LONG BRAKE FACTOR: Brake intensity factor along logitudinal axis'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- LAT BRAKE FACTOR: Brake intensity factor along lateral axis'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- VERT BRAKE FACTOR: Brake intensity factor along vertical axis'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- SPACE BRAKE INTENSIITY: Multiplication factor for all 3 above factors in space'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- GYRO AXIS: Use gyro to set the Forward/Right/Up of the construct'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- PITCH TILTING: Adjust the default pitch angle of the construct'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- ROLL TILTING: Adjust the default roll angle of the construct'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- HOVERS ON/OFF: Activate/deactivate hover eng'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- HOVER MODE: Dynamic/Static enables altitude stabilisation'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- HOVER ALTITUDE: Altitude for Static Mode'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- VBOOSTER ON/OFF/AUTO: Activate/deactivate booster eng (Auto = deactivated in atmo)'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- AGG ALTITUDE: Adjust the Anti-gravity engine altitude'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- ENGINES ON/OFF: Activate/deactivate all the eng'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- ENGINES AUTO: Long press "C" on the ground to deactivate all eng'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- ECO MODE: Deactivate all eng that doesnt have the engine tag "eco"'..h2..[[
      ]]..h1..lineSpace..[[">]]..'Warning: make sure you set the tag "eco" to at least '..h2..[[
      ]]..h1..lineSpace..[[">]]..'one of each type of eng (thrusters / hovers / vboosters)'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- ATMO MAX SPEED: Speed limiter for atmosphere'..h2..[[
     </text>]]
     
    help.autopilotSettings = [[
     <text x="500" y="30" font-size="]]..fontSize..[[" text-anchor="middle">
      <tspan x="500" font-size="]]..fontSize*2 ..[[">]]..'AUTOPILOT SETTINGS'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'This MENU is dedicated to autopilot features settings'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- AUTO BRAKE SPEED: Speed under which auto braking will occure (auto brake for Travel mode)'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- AUTO LEVEL ALT. MAX: Altitude under wich auto stabilisation will be effective'..h2..[[
      ]]..h1..lineSpace ..[[">]]..'- ROLL STABILISATION: Automatic roll stabilisation'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- TURN ASSIST: Automatic pitch and yaw while rolling'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- TURN ASSIST MIN ROLL: Minimum roll angle for the turn assist to occure'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- TURN ASSIST MAX PITCH: Maximum pitch angle for the turn assist to occure'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- PITCH STABILISATION: Automatic pitch stabilisation'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- AUTO PITCH AMPLITUDE: Angle under which pitch stabilisation will occure'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- ALTITUDE STABILISATION: Automatic pitch to keep a stable altitude'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- ATMO ANTI-STALL: Will try to prevent construct from stalling in atmo'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- INERTIA AUTO BRAKE: Anti drift auto braking on/off'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- ATMO INERTIA FACTOR: Amto drift sensibility factor'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- SPACE INERTIA FACTOR: Space drift sensibility factor'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- SPACE AUTO PROGRADE: Force align construct to its velocity vector'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- SPACE AUTO ORBIT SPEED: Auto speed adjustment for orbit'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- ROCKETS MAX SPEED: Speed limiter in atmo for rockets(set -1 to disable)(WIP)'..h2..[[
      ]]..h1..lineSpace..[[">]]..'*Rockets are completly disabled at the moment'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- DOCKING PARENT: MANUAL / CLOSEST / OWNER dok parent type'..h2..[[
     </text>]]
     
    help.widgets = [[
     <text x="500" y="30" font-size="]]..fontSize..[[" text-anchor="middle">
      <tspan x="500" font-size="]]..fontSize*2 ..[[">]]..'WIDGETS SETTINGS'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'This MENU is dedicated to widgets settings'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- All widgets are resizeable, repositionable,'..h2..[[
      ]]..h1..lineSpace..[[">]]..'by using the "Quick tool Bar" menu.'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- Widgets with the "ALT" option on will only popup'..h2..[[
      ]]..h1..lineSpace..[[">]]..'when "Quick tool Bar" menu is opened.'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- Widgets with the "AUTO" option on will only popup'..h2..[[
      ]]..h1..lineSpace..[[">]]..' when the needed conditions they requiere are active.'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- Too many opened widgets can cause CPU overload'..h2..[[
      ]]..h1..lineSpace..[[">]]..'Use them wisely!'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- Custom widgets are fully customizable and modular'..h2..[[
      ]]..h1..lineSpace..[[">]]..'they can be found and edited in the WIDGETS folder.'..h2..[[
      ]]..h1..lineSpace..[[">]]..'File name number must be consecutive'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- Custom Widgets are usingwindows system to display custom SVGs,'..h2..[[
      ]]..h1..lineSpace..[[">]]..'they can also include custom buttons and thrust overide'..h2..[[
     </text>]]
     
    help.keybingParams = [[
     <text x="500" y="30" font-size="]]..fontSize..[[" text-anchor="middle">
      <tspan x="500" font-size="]]..fontSize*2 ..[[">]]..'KEYBINDS PARAMETERS'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'This MENU is dedicated to keybind parameters'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- FLIGHT MODE: Warning! Default flight mode keybind is deactivated'..h2..[[
      ]]..h1..lineSpace..[[">]]..'CRUISE: Use throttle to control the construct speed and brakes'..h2..[[
      ]]..h1..lineSpace..[[">]]..'TRAVEL: Use throttle to control the construct thrust'..h2..[[
      ]]..h1..lineSpace..[[">]]..'PLATFORM: Use ASDW to move around, press shift for full power'..h2..[[
      ]]..h1..lineSpace..[[">]]..'DRONE: Use ASDW to move around using hover or vertical eng.'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- Hover eng must be set to disable thrust along gravity.'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- QE/AD INVERT: Inverts keybind for yaw and roll'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- DOUBLE TAP TIME: Time in seconds for activating a double tap'..h2..[[
      ]]..h1..lineSpace..[[">]]..'*DOUBLE TAP FEATURES: Backburn stop in space using "double tap CTRL"' ..h2..[[
      ]]..h1..lineSpace..[[">]]..'*DOUBLE TAP FEATURES: Vertical stop and hovering in atmo using "double tap CTRL"' ..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- SHIFT LOCK: Enable the "SHIFT key to lock in place a control key'..h2..[[
      ]]..h1..lineSpace..[[">]]..'First hold "SHIFT" then press and release any control key, then release "SHIFT"'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- FREEZE CONTROL: Freeze/unfreeze movements while using a remote or ECU'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- FREEZE VIEW: Freeze/unfreeze camera movements'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- MOUSE CONTROL: Alternate toggle able keyboard + mouse scheme'..h2..[[
      ]]..h1..lineSpace..[[">]]..'- M-C SENSITIVITY: Sensibility of the mouse control'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- ALT + 3456789 constumizable keybinds for selected features'..h2..[[
     </text>]]
     
    help.q = [[
     <text x="500" y="30" font-size="]]..fontSize..[[" text-anchor="middle">
      <tspan x="500" font-size="]]..fontSize*2 ..[[">]]..'QUICK TOOL BAR'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'This MENU is dedicated to the quick menu tool bar'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- While in the "ALT+1" main menu, hold "CTRL" then click to add'..h2..[[
      ]]..h1..lineSpace..[[">]]..'or remove shortcut buttons to the Quick Tool Bar'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- Quick Tool Bar is accessible by double taping and holding "ALT" key while on the main screen'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- Widgets are interactible while Quick Tool Bar is opened'..h2..[[
      
      ]]..h1..lineSpace*2 ..[[">]]..'- Certain widgets with "ALT" parameters will only popup with the Quick Tool Bar'..h2..[[
     </text>]]
      
    help.print = function(system)
     system.print("------------------------")
     system.print("HELP / KEYBINDS")
     system.print("------------------------")
     system.print("ALT + 1 = open/close Main settings menu")
     system.print("Double Tap ALT while flying to acces quicktool menu")
     system.print("Hold SHIFT + Control Key = key lock(if enabled in the menu)")
     system.print("Double Tap CTRL in space = backburn stop")
     system.print("------------------------")
     system.print("HELP / COMMANDS")
     system.print("------------------------")
     system.print("help = print the help menu")
     system.print("reset all: formats databank to factory settings")
     system.print("type in a ::pos{} coordinate to translate it to world coordinate")
     system.print("------------------------")
     system.print("End of the help menu")
     system.print("------------------------")
    end
    --return help
  onStart:
   lua: |
    Kinematic = {} -- Part of Jaylebreak's flight files, modified slightly

    local clamp = utils.clamp
   
    function Kinematic.computeAccelerationTime(initial, acceleration, final)
     -- ans: t = (vf - vi)/a
     return (final - initial)/acceleration
    end

    function Kinematic.BrakeDistanceAndTime(initial,final,mass,thrust,maxBrakeForce,atmosDensity,gravityA,zAxis,zBrakeClamp)
     maxBrakeForce = maxBrakeForce or 0
     atmosDensity = atmosDensity or 1
     gravityA = gravityA or 9.89
     zAxis = zAxis or false
     zBrakeClamp = zBrakeClamp or 0.14 --0.1592 -- can't fall slower than this m/s 

     local gF = gravityA*mass
     local gA = gF/mass
     local tA = thrust / -mass
     local t, d = 0,0
     local zBrakeScale = 1
     if zAxis then zBrakeScale = clamp(gF/(maxBrakeForce*zBrakeClamp),0,1) end
     local bA = -(maxBrakeForce*atmosDensity*zBrakeScale)/mass

     if initial <= final then
      return 0, 0, 0  -- trivial
     elseif tA+bA >= 0 then
      return -1, -1, -1 -- no solution
     end
    
     if final < 100 then
      -- first calculate distance to 100 m/s
      local t1 = 0
      local d1 = 0
      if initial > 100 then 
       local a = tA+bA+gA
       t = Kinematic.computeAccelerationTime(initial, a, 100)
       d = initial*t + a*t*t/2
       initial = 100
      end

      -- iterate over remaining speed
      local initialVel = initial
      local stepSize = 2
      while initialVel > final do
       local t2, d2 = 0,0
       local targetVel = initialVel - stepSize > final and initialVel - stepSize or final
       local aveVel = (targetVel + initialVel)/2
       local brakeForce = 0
       if zAxis then 
        local bBottom = aveVel/(100/clamp(1+(6.28-(maxBrakeForce/gF)),1,100))*maxBrakeForce
        local bUpper = maxBrakeForce * clamp(aveVel/100,0.09,1)^1.01
        brakeForce = math.min(bBottom,bUpper) * zBrakeScale * atmosDensity
       else
        brakeForce = maxBrakeForce * clamp(aveVel/100,0.1,1) * atmosDensity
       end
       local bA2 = -brakeForce/mass
       local a = tA+bA2+gA
       if a > 0 then return d, t, initialVel end -- can't slow to target vel
       t2 = Kinematic.computeAccelerationTime(initialVel, a, targetVel)
       d2 = initialVel*t2 + a*t2*t2/2
       t = t2 + t
       d = d2 + d
       initialVel = targetVel
      end
     else
      --Directly calculate since end is > 100
      local a = tA+gA+bA
      t = Kinematic.computeAccelerationTime(initial, a, final)
      d = initial*t + a*t*t/2
     end
     return d, t, 0 --distance, time, minfall speed
    end

    function Kinematic.computeTravelTime(initial, acceleration, distance)
     -- quadratic equation: t=(sqrt(2ad+v^2)-v)/a
     if distance == 0 then return 0 end
     if acceleration ~= 0 then
      return (math.sqrt(2*acceleration*distance+initial^2) - initial)/acceleration
     end
     assert(initial > 0, 'Acceleration and initial speed are both zero.')
     return distance/initial
    end

    function Kinematic.maxInitialVelocity(distance,final,mass,thrust,hov,hoverDist,maxBrakeForce,atmosDensity,gravityA,zAxis,zBrakeClamp)
     if distance <= 0 then return -1 end
     
     hov = hov or 0
     hoverDist = hoverDist or 0
     maxBrakeForce = maxBrakeForce or 0
     atmosDensity = atmosDensity or 1
     gravityA = gravityA or 9.89
     zAxis = zAxis or false
     zBrakeClamp = zBrakeClamp or 0.14 --0.1592 -- can't fall slower than this m/s 

     local gF = gravityA*mass
     local gA = gF/mass
     local tA = thrust / -mass
     local hA = hov / -mass
     local bA = -maxBrakeForce/mass

     local function brakeAcceleration(velocity)
      if maxBrakeForce <= 0 or velocity == 0 then return 0 end
      local brakeForce = 0
      if zAxis then 
       local zBrakeScale = clamp(gF/(maxBrakeForce*zBrakeClamp),0,1)
       local bBottom = velocity/(100/clamp(1+(6.28-(maxBrakeForce/gF)),1,100))*maxBrakeForce
       local bUpper = maxBrakeForce * clamp(velocity/100,0.09,1)^1.01
       brakeForce = math.min(bBottom,bUpper) * zBrakeScale * atmosDensity
      else
       brakeForce = maxBrakeForce * clamp(velocity/100,0.1,1) * atmosDensity
      end
      return -brakeForce/mass
     end
     
     local increment = 2
     local distTraveled = 0
     local vCurrent = final

     while distTraveled < distance do
      local hAs = distTraveled <= hoverDist and hA or 0
      local bAs = brakeAcceleration(vCurrent)
      local a = tA+bAs+gA+hAs
      if a > 0 then return vCurrent end
      local distStep = distTraveled + increment < distance and increment or distance - distTraveled
      local vInitial = vCurrent
      local ts = Kinematic.computeTravelTime(vInitial, -a, distStep)
      vCurrent = vCurrent + (-a) * ts
      distTraveled = distTraveled + distStep
     end
     return vCurrent
    end
  onStart:
   lua: |
    local pide = {}
    pide.__index = pide;
    -- Constructor
    local function new(p, i, d, tTime, minLimit, maxLimit)
     return setmetatable({
      -- Controller Gains
      Kp = p,
      Ki = i,
      Kd = d,
      
      -- Derivative low-pass filter time constant
      tau = 0,
      
      -- Output limits
      limMin = minLimit or 0,
      limMax = maxLimit or 100,
      
      -- Sample time in seconds
      tTime = tTime or 1,
      
      -- Controller memory
      integrator = 0,
      err = 0,
      prevError = 0,
      differentiator = 0,
      prevMeasurement = 0,
      output = 0
     }, pide)
    end

    function pide:update(setpoint, measurement)
     -- Error signal
     err = setpoint - measurement
     
     -- proportion Term
     proportional = self.Kp * err
     
     -- Integral Term
     self.integrator = self.integrator + 0.5 * self.Ki * self.tTime * (err + self.prevError)
     
     -- Anti-Windup integrator clamping
     if self.integrator > self.limMax then
      self.integrator = self.limMax
     end
     
     if self.integrator < self.limMin then
      self.integrator = self.limMin
     end
     
     -- Derivative Term
     self.differentiator = -(2.0 * self.Kd * (measurement - self.prevMeasurement) + (2 * self.tau - self.tTime) * self.differentiator) / (2.0 * self.tau + self.tTime)
     
     -- Compute output and apply limits
     self.out = proportional + self.integrator + self.differentiator
     
     if self.out > self.limMax then
      self.out = self.limMax
     end
     
     if self.out < self.limMin then
      self.out = self.limMin
     end

     -- Store error and measurement for later use
     self.prevError = err
     self.prevMeasurement = measurement
     
     return self.out
    end

    function pide:setTau(tau)
     self.tau = tau
    end

    function pide:setTime(t)
     self.tTime = t
    end

    function pide:setLimits(minL, maxL)
     self.minLimit = minL
     self.maxLimit = maxL
    end

    function pide:reset()
     self.integrator = 0
     self.err = 0
     self.prevError = 0
     self.differentiator = 0
     self.prevMeasurement = 0
     self.output = 0
    end

    -- the module
    pid3 = setmetatable(
     {
      new = new--, update = update, setTau = setTau, setTime = setTime, setLimits = setLimits
     }, {
      __call = function(_, ...) return new(...) end
     }
    )
  onStart:
   lua: |
    -- navigator --
    local utils = require("cpml/utils")
    local pid = require("cpml/pid")

    local sign, clamp, abs, sqrt, min, max = utils.sign, utils.clamp, math.abs, math.sqrt, math.min, math.max
    MasterModeList = {
     "CRUISE",
     "TRAVEL",
     "PLATFORM",
     "DRONE",
    }

    NavigatorPlusPlus = {}
    NavigatorPlusPlus.__index = NavigatorPlusPlus

    function NavigatorPlusPlus.new()
     local self = setmetatable({}, NavigatorPlusPlus)

     self.boosterState = 0
     self.boosterStateHasChanged = false
     self.boosterMaxSpeed = 1200

     self.MasterMode = "CRUISE"
     self.previousMasterMode = ""
     self.throttleValue = 0
     self.previousThrottleValue = 0
     self.mouseWheelValue = 0
     self.maxSpeedKMPH = 49999

     self.targetSpeedRangesSteps = {5,10,20,40,100,200,500,1000}
     self.targetSpeedRanges = {20,60,140,300,800,2000,7000,49999}
     self.currentTargetSpeedStep = 0
     self.atmoMaxSpeed = construct.getFrictionBurnSpeed() * 3.6 * 0.8

     self.targetGAC = unit.computeGroundEngineAltitudeStabilizationCapabilities()
     return self
    end

    function NavigatorPlusPlus.setAtmoMaxSpeed(self,speed)
     self.atmoMaxSpeed = speed
    end

    function NavigatorPlusPlus.getAtmoMaxSpeed(self)
     return self.atmoMaxSpeed
    end

    ------------------
    -- Throttle setup
    ------------------
    function NavigatorPlusPlus.setupCustomTargetSpeedRanges(self, customTargetSpeedRanges)
     self.customTargetSpeedRanges = customTargetSpeedRanges
    end

    function NavigatorPlusPlus.getTargetSpeedRangeStep(self,value)
     for i, v in ipairs(self.targetSpeedRanges) do
      self.currentTargetSpeedStep = self.targetSpeedRangesSteps[i]
      if value > 0 then
       if abs(self.throttleValue) < v then
        return self.currentTargetSpeedStep
       end
      else
       if abs(self.throttleValue) <= v then
        if self.targetSpeedRangesSteps[i-1] ~= nil then
         if abs(self.throttleValue) - self.currentTargetSpeedStep <= self.targetSpeedRanges[i-1] then
          self.currentTargetSpeedStep = abs(self.throttleValue) - self.targetSpeedRanges[i-1]
         end
        end
        return self.currentTargetSpeedStep
       end
      end
     end
    end

    function NavigatorPlusPlus.updateThrottleValue(self,value)
     if value ~= 0 then self:prepareForFlight() end
     if self.MasterMode == "CRUISE" then
      self.throttleValue = clamp(self.throttleValue + value * self:getTargetSpeedRangeStep(value),-self.maxSpeedKMPH,self.maxSpeedKMPH)
     elseif self.MasterMode == "TRAVEL" then
      self.throttleValue = clamp(self.throttleValue + value/10,-1,1)
     else self.throttleValue = 0
     end
     if abs(self.throttleValue) < 0.01 then self.throttleValue = 0 end
    end

    function NavigatorPlusPlus.setThrottleValue(self,value)
     if value ~= 0 then self:prepareForFlight() end
     if self.MasterMode == "CRUISE" then
      self.throttleValue = clamp(value,-self.maxSpeedKMPH,self.maxSpeedKMPH)
     elseif self.MasterMode == "TRAVEL" then
      self.throttleValue = clamp(value,-1,1)
     else self.throttleValue = 0
     end
    end

    function NavigatorPlusPlus.prepareForFlight(self)
     autoLand, autoStart = false,false
     enginesToggle()
     if pkM then
      pkM = false
      if P.KP.flM.value ~= self.MasterMode then
       self:setMasterMode(P.KP.flM.value)
      end
     end
    end

    function NavigatorPlusPlus.resetThrottleValue(self)
     self.throttleValue = 0
    end

    function NavigatorPlusPlus.getThrottleValue(self)
     return self.throttleValue
    end

    -- Master Mode --
    function NavigatorPlusPlus.setMasterMode(self,mode)
     local cAV = construct.getVelocity()
     local cAVx, cAVy, cAVz = cAV[1], cAV[2], cAV[3]
     --local xyzSpeedKPH = sqrt((cAVx^2+cAVy^2+cAVz^2))*3.6
     self.MasterMode = mode
     if self.MasterMode == "CRUISE" then
      self.throttleValue = ySpeedKPH > 10 and ySpeedKPH or 0
     elseif self.MasterMode == "TRAVEL" or self.MasterMode == "PLATFORM" or self.MasterMode == "DRONE" then
      self:resetThrottleValue()
     end
     self.TargetLongitudinalSpeedPID:reset()
     self.TargetLateralSpeedPID:reset()
     self.TargetVerticalSpeedPID:reset()
     MM = self.MasterMode
    end

    function NavigatorPlusPlus.buildPIDs(self)
     self.TargetLongitudinalSpeedPID = pid.new(10*P.ES.loF.value, 0, 10*P.ES.loF.value)
     self.TargetLateralSpeedPID = pid.new(10*P.ES.laF.value, 0, 10*P.ES.laF.value)
     self.TargetVerticalSpeedPID = pid.new(10*P.ES.vtF.value, 0, 10*P.ES.vtF.value)
    
     self.LongitudinalBrakePID = pid.new(1, 0, 10)
     self.LateralBrakePID = pid.new(1, 0, 10)
     self.VerticalBrakePID = pid.new(1, 0, 10)
    end

    function NavigatorPlusPlus.getMasterMode(self)
     return self.MasterMode
    end

    -- Update --
    function NavigatorPlusPlus.throttleUpdate(self)
     local ThrottleInputFromMouseWheel = system.getThrottleInputFromMouseWheel()
      if self.mouseWheelValue ~= ThrottleInputFromMouseWheel then
       self:updateThrottleValue(ThrottleInputFromMouseWheel)
      end
     self.mouseWheelValue = ThrottleInputFromMouseWheel
    end
    function NavigatorPlusPlus.updateMaxSpeed(self,speed)
     self.maxSpeedKMPH = speed
     self.targetSpeedRanges = {20,60,140,300,800,2000,7000,49999,self.maxSpeedKMPH}
    end

    -----------------
    -- Acceleration 
    ----------------
    function NavigatorPlusPlus.maxForceForward(self)
     local cOF = {cOFx, cOFy, cOFz}--construct.getOrientationForward()
     local maxKPAlongAxis = construct.getMaxThrustAlongAxis('thrust analog longitudinal', cOF)
     if inspace == 1 then
      return maxKPAlongAxis[3]~= nil and maxKPAlongAxis[3] or 0
     else
      return maxKPAlongAxis[1]~= nil and maxKPAlongAxis[1] or 0
     end
    end

    function NavigatorPlusPlus.maxForceBackward(self)
     local cOF = {cOFx, cOFy, cOFz}--construct.getOrientationForward()
     local maxKPAlongAxis = construct.getMaxThrustAlongAxis('thrust analog longitudinal', cOF)
     if inspace == 1 then
      return maxKPAlongAxis[4]~= nil and maxKPAlongAxis[4] or 0
     else
      return maxKPAlongAxis[2]~= nil and maxKPAlongAxis[2] or 0
     end
    end

    function NavigatorPlusPlus.getMaxKPA(self)
     return self:maxForceForward(), self:maxForceBackward()
    end

    function NavigatorPlusPlus.maxForceUp(self)
     local cOUP = {cOUPx, cOUPy, cOUPz}--construct.getOrientationUp() construct.getOrientationRight()
     local tags = 'thrust analog not_ground '
     if bCM and gyro.isActive() == true then tags = tags .. 'lateral' else tags = tags .. 'vertical' end
     local maxKPAlongAxis = construct.getMaxThrustAlongAxis(tags, cOUP)
     if inspace == 1 then
      return maxKPAlongAxis[3]~= nil and maxKPAlongAxis[3] or 0
     else
      return maxKPAlongAxis[1]~= nil and maxKPAlongAxis[1] or 0
     end
    end

    function dotVec(x1,y1,z1,x2,y2,z2)
     return x1*x2 + y1*y2 + z1*z2
    end

    function NavigatorPlusPlus.composeAccelerationFromTargetSpeed(self,axis,speed) --axis: longitudinal / lateral / vertical // speed: in kmph
     local cAV = construct.getWorldVelocity()
     local cAVx, cAVy, cAVz = cAV[1], cAV[2], cAV[3]
     local gravityV = core.getWorldGravity()
     local gx, gy, gz = gravityV[1], gravityV[2], gravityV[3]
     local AWDx, AWDy, AWDz = 0, 0, 0 --AxisWorldDirection
     local AxisSpeed = 0
     tSpeed = clamp(speed, -self.maxSpeedKMPH+10, self.maxSpeedKMPH-10)
     if inAtmo and tSpeed ~= 0 then
      tSpeed = clamp(tSpeed, -self.atmoMaxSpeed, self.atmoMaxSpeed)
     end
     tSpeed = tSpeed * 0.27777777777
     if axis == "longitudinal" then
      AWDx, AWDy, AWDz = cWOFx, cWOFy, cWOFz
      AxisSpeed = dotVec(cAVx, cAVy, cAVz, AWDx, AWDy, AWDz)
     elseif axis == "lateral" then
      AWDx, AWDy, AWDz = cWORx, cWORy, cWORz
      AxisSpeed = dotVec(cAVx, cAVy, cAVz, AWDx, AWDy, AWDz)
     elseif axis == "vertical" then
      AWDx, AWDy, AWDz = cWOUPx, cWOUPy, cWOUPz
      AxisSpeed = dotVec(cAVx, cAVy, cAVz, AWDx, AWDy, AWDz)
     end
     local GravityAcc = dotVec(gx, gy, gz, AWDx, AWDy, AWDz)
     local WAFA = construct.getWorldAirFrictionAcceleration()
     local WAFAx, WAFAy, WAFAz = WAFA[1], WAFA[2], WAFA[3]
     local AirResistanceAcc = dotVec(WAFAx, WAFAy, WAFAz, AWDx, AWDy, AWDz)
     local Acc = 0
     if axis == "longitudinal" then
      self.TargetLongitudinalSpeedPID:inject(tSpeed - AxisSpeed)
      Acc = self.TargetLongitudinalSpeedPID:get()
     elseif axis == "lateral" then
      self.TargetLateralSpeedPID:inject(tSpeed - AxisSpeed)
      Acc = self.TargetLateralSpeedPID:get()
     elseif axis == "vertical" then
      self.TargetVerticalSpeedPID:inject(tSpeed - AxisSpeed)
      Acc = self.TargetVerticalSpeedPID:get()
     end
     if self.MasterMode == "DRONE" then
      Acc = (tSpeed - AxisSpeed)
     end
     local xyzSpeedMPS = sqrt(cAVx^2+cAVy^2+cAVz^2)
     if autoLand == true and xyzSpeedMPS > 3 then
      Acc = (tSpeed - AxisSpeed) * 5
     end
     local AAG = Acc - GravityAcc - AirResistanceAcc
     local FAx = AAG * AWDx
     local FAy = AAG * AWDy
     local FAz = AAG * AWDz
     return FAx, FAy, FAz
    end

    function NavigatorPlusPlus.composeBrakeAcceleration(self,axis,speed)
     tSpeed = speed ~= nil and speed * 0.27777777777 or 0
     local cAV = construct.getWorldVelocity()
     local cAVx, cAVy, cAVz = cAV[1], cAV[2], cAV[3]
     local gravityV = core.getWorldGravity()
     local gx, gy, gz = gravityV[1], gravityV[2], gravityV[3]
     local WAFA = construct.getWorldAirFrictionAcceleration()
     local WAFAx, WAFAy, WAFAz = WAFA[1], WAFA[2], WAFA[3]
     local AWDx, AWDy, AWDz = 0, 0, 0 --AxisWorldDirection
    
     if axis == "longitudinal" then
      AWDx, AWDy, AWDz = normalizeVec(cWOFx, cWOFy, cWOFz)
     elseif axis == "lateral" then
      AWDx, AWDy, AWDz = normalizeVec(cWORx, cWORy, cWORz)
     elseif axis == "vertical" then
      AWDx, AWDy, AWDz = normalizeVec(cWOUPx, cWOUPy, cWOUPz)
     end
    
     local AxisSpeed = dotVec(cAVx, cAVy, cAVz, AWDx, AWDy, AWDz)
     local gravityAcc = dotVec(gx, gy, gz, AWDx, AWDy, AWDz)
     local fAirAcc = dotVec(WAFAx, WAFAy, WAFAz, AWDx, AWDy, AWDz)
     local Acc = tSpeed - AxisSpeed
     if self.MasterMode == "DRONE" and autoLand == true and velMag > 3 then
      Acc = (tSpeed - AxisSpeed) * 10
     end
     if brakeInput == 1 and velMag > 3 then Acc = (tSpeed - AxisSpeed) * 10 end
     local aRAC = Acc - gravityAcc - fAirAcc
     return aRAC * AWDx, aRAC * AWDy, aRAC * AWDz
    end

    function NavigatorPlusPlus.composeAccelerationFromThrottle(self)
     if inAtmo and self.atmoMaxSpeed > 0 and xyzSpeedKPH > self.atmoMaxSpeed - 4 then
      local FAx, FAy, FAz = self:composeAccelerationFromTargetSpeed('longitudinal',self.atmoMaxSpeed) --axis: longitudinal / lateral / vertical // speed: in kmph
      return FAx, FAy, FAz
     else
      local cM = construct.getTotalMass()
      local throttleForce = 0
      if self.throttleValue > 0 then
       local maxAtmoForceForward = self:maxForceForward()
       throttleForce = self.throttleValue * maxAtmoForceForward
      elseif self.throttleValue < 0 then
       local maxAtmoForceBackward = self:maxForceBackward()
       throttleForce = -self.throttleValue * maxAtmoForceBackward
      end
      local Acc = throttleForce / cM
      local FAx = Acc * cWOFx
      local FAy = Acc * cWOFy
      local FAz = Acc * cWOFz
      return FAx, FAy, FAz
     end
    end

    function NavigatorPlusPlus.updateHovers(self,input,hoA,mode)
     if mode == "STATIC" then
      if input == 0 then
       if hoA ~= nil then
       hoA = clamp(hoA, -999999, self.targetGAC[1])
        if Engines == true then
         unit.activateGroundEngineAltitudeStabilization(hoA)
        end
       end
      else
       unit.deactivateGroundEngineAltitudeStabilization()
      end
     else unit.deactivateGroundEngineAltitudeStabilization()
     end
    end


  onStart:
   lua: |
    -- CUSTOM WINDOWS --
    windowWidth = 260
    titleHeight = 25
    buttonWidth = 160
    buttonHeight = 25
    buttonGape = 5

    local TABLE = {}
    TABLE = {
     index = function (t,val)
      for i,v in ipairs(t) do
       if v == val then 
        return i
       end
      end
      return nil
     end,

     valUp = function (t,val)
      local index = TABLE.index(t,val)
      local newVal 
      if index == nil then
       newVal = t[1]
      elseif t[index+1] == nil then
       newVal = t[1]
      else
       newVal = t[index+1]
      end
      return newVal
     end,

     valDown = function (t,val)
      local index = TABLE.index(t,val)
      local newVal
      if index == nil then
       newVal = t[1]
      elseif t[index-1] == nil then
       newVal = t[#t]
      else
       newVal = t[index-1]
      end
      return newVal
     end,
    }

    function Save_Window_Pos(name,posX,posY)
     for i, v in ipairs(P) do
      if P.w_title == name then
       P.w_pos.x = posX
       P.w_pos.y = posY
       return
      else
       for k, l in ipairs(P[v]) do
        if P[v].w_title == name then
         P[v].w_pos.x = posX
         P[v].w_pos.y = posY
         return
        end
       end
      end
     end
     if name == P.help_menu.w_title then 
      P.help_menu.w_pos.x = posX
      P.help_menu.w_pos.y = posY
      return
     elseif name == P.QuickToolBar.w_title then 
      P.QuickToolBar.w_pos.x = posX
      P.QuickToolBar.w_pos.y = posY
      return
     end
     
     for i, v in pairs(P) do
      if string.sub (tostring(i),1,7) == "Widget_" and P[i].w_title == name then
       P[i].w_pos.x = posX
       P[i].w_pos.y = posY
       return
      end
     end
    end

    SubMenusButtonsClickFunction = function(v, l)
     return function()
      local tv = type(P[v][l].value)
      if CTRL == false then
       if mouseWheel == 0 then
        if tv == "number" then -- Set buttons functions
         P[v][l].increment = TABLE.valUp(P[v][l].step, P[v][l].increment)
        elseif tv == "string" then
         P[v][l].value = TABLE.valUp(P[v][l].range, P[v][l].value)
        elseif tv == "boolean" then
         P[v][l].value = not P[v][l].value
        elseif tv == "function" then
         P[v][l].value()
        end
       elseif mouseWheel > 0 then
        if tv == "number" then
         P[v][l].value = P[v][l].value + P[v][l].increment
         P[v][l].value = utils.clamp(P[v][l].value,P[v][l].range[1],P[v][l].range[2])
         if math.abs(P[v][l].value) < 0.0009 then P[v][l].value = 0 end
        elseif tv == "string" then
         P[v][l].value = TABLE.valUp(P[v][l].range, P[v][l].value)
        elseif tv == "boolean" then
         P[v][l].value = not P[v][l].value
        end
       elseif mouseWheel < 0 then
        if tv == "number" then
         P[v][l].value = P[v][l].value - P[v][l].increment
         P[v][l].value = utils.clamp(P[v][l].value,P[v][l].range[1],P[v][l].range[2])
         if math.abs(P[v][l].value) < 0.0009 then P[v][l].value = 0 end
        elseif tv == "string" then
         P[v][l].value = TABLE.valDown(P[v][l].range, P[v][l].value)
        elseif tv == "boolean" then
         P[v][l].value = not P[v][l].value
        end
       end
      else
       if P.w_open == true then
        P[v][l].q = not P[v][l].q
       end
      end
      updateParams()
      if v == "MS" then WindowLib:winlibCSSUpdate() end
      if P.QuickToolBar.w_open == true then checkWidgets() end
      windowsShow()
     end
    end

    function Cursor_Builder()
     if P.w_open == true or P.QuickToolBar.w_open == true then
      local cursorPos = vec2(WindowLib:getMousePos())
      local window = WindowLib:new(
       [[<div style='background:rgba(0, 0, 0, 0)'>
       <svg height="50" width="50">
       <polygon points="0,0 25,22.5 10,20 5,32.5" 
       stroke="lightsteelblue" stroke-width="1.5" fill="white"/>
       </svg></div>
       ]],{class = "widgets", name = "cursor", width = 50, height = 50, posX = cursorPos.x, posY = cursorPos.y, fixed = false, draggable = false, alwaysOnTop = true})
     end
    end

    function Quick_Menu_Builder()
     if P.w_open == false and ALT == true then
     system.showHelper(0)
      local svg = [[<style>
      .button {fill:]]..P.MS.WTC.value..[[; font-size:12px; text-anchor:end; font-family:Play; alignment-baseline:middle}
      </style>]]
      local buttons = {}
      local ind = 0
      -- Creating favorit buttons
      for i, v in ipairs(P) do
       for k, l in ipairs(P[v]) do
        if l ~= "separator" then
         if P[v][l].q == true then
          local increment = ""
          if P[v][l].increment ~= nil then increment = " (+-"..tostring(P[v][l].increment)..")" end
          if type(P[v][l].value) ~= "function" then
           svg = svg .. [["<text class="button" x="]]..windowWidth - 10 ..[[" y="]].. 15 + ind * (buttonHeight + buttonGape) ..[[" >]]..string.sub (tostring(P[v][l].value),1,10):upper()..increment..[[</text>"]]
          end
          local nb = WindowLib:buttonsNew(P[v][l].name, SubMenusButtonsClickFunction(v,l), {width = buttonWidth, height = buttonHeight, posX = 5, posY = (titleHeight + 5 + ind * (buttonHeight + buttonGape))})
          ind = ind + 1
          buttons[ind] = nb
         end
        end
       end
      end
      -- Creating the window t1
      if ind > 0 then
       local window = WindowLib:new(
        [[<div style='background:rgba(0, 0, 0, 0); text-align:middle; vertical-align: text-top'>
        <svg height="5000" width="500">
        ]]..svg..[[
        </svg></div>
        ]],
        {name = P.QuickToolBar.w_title, title = P.QuickToolBar.w_title, width = windowWidth, height = (titleHeight + ind*(buttonHeight+buttonGape)+buttonGape), posX = P.QuickToolBar.w_pos.x, posY = P.QuickToolBar.w_pos.y, fixed = false, draggable = true, alwaysOnTop = false},buttons)
      end
     end
    end

    function Params_Menu_Builder()
     if P.w_open == true then
      system.showHelper(0)
      local mainMenuButtons = {}
      local buttonClickFunction = nil
      local indMMB = 0
      local ind = 0
      --ComposeQuickToolMenu()
      for i, v in ipairs(P) do
       ind = 0
       local svg = [[<style>
       .button {fill:]]..P.MS.WTC.value..[[; font-size:12px; text-anchor:end; font-family:Play; alignment-baseline:middle}
       </style>]]
       local buttons = {}
       --Building the main menu bar buttons
       if P[v] ~= P.QuickToolBar then
        buttonClickFunction = function()
         P[v].w_open = not P[v].w_open
         WindowLib = WLP.init(system)
         Params_Menu_Builder()
         Help_Menu_Builder()
         Cursor_Builder()
        end
        local mmb = WindowLib:buttonsNew(P[v].w_title, buttonClickFunction, {width = windowWidth, height = buttonHeight, posX = (5 + indMMB * (windowWidth + buttonGape)), posY = 5})
        indMMB = indMMB + 1
        mainMenuButtons[indMMB] = mmb
       end
       --Building the windows buttons
       for k, l in ipairs(P[v]) do
        local increment = ""
        local QTBtag = ""
        if P[v].w_open == true then
         if l ~= "separator" then
          if P[v][l].increment ~= nil then increment = " (+-"..tostring(P[v][l].increment)..")" end
          if P[v][l].q == true then QTBtag = "*" end
          local nb = WindowLib:buttonsNew(P[v][l].name..QTBtag, SubMenusButtonsClickFunction(v,l), {width = buttonWidth, height = buttonHeight, posX = 5, posY = (titleHeight + 5 + (k-1) * (buttonHeight + buttonGape))})
          ind = ind + 1
          buttons[ind] = nb
          if type(P[v][l].value) ~= "function" then
           svg = svg .. [["<text class="button" x="]]..windowWidth - 10 ..[[" y="]].. 15 + (k-1) * (buttonHeight + buttonGape) ..[[" >]]..string.sub (tostring(P[v][l].value),1,10):upper()..increment..[[</text>"]]
          end
         else
          local nb = WindowLib:buttonsNew("", nil, {class= "separator", width = 0, height = 0, posX = 0, posY = (titleHeight + 5 + (k-1) * (buttonHeight + buttonGape))})
          ind = ind + 1
          buttons[ind] = nb
          svg = svg .. [["<line x1="5" y1="]].. 12 + (k-1) * (buttonHeight + buttonGape) ..[[" x2="]]..windowWidth - 10 ..[[" y2="]].. 12 + (k-1) * (buttonHeight + buttonGape) ..[[" stroke="]]..P.MS.BBC.value..[[" fill="None" stroke-width="0.5"/>"]]
         end
        end
       end
       
       -- Creating the sub menu window
       if ind > 0 and v ~= P.QuickToolBar then
        local ww = windowWidth
        local wclass = nil
        local whtml = ""
        local window = WindowLib:new(
        [[<div><svg height="1080" width="1920">
        ]]..svg..whtml..[[
        </svg></div>
        ]],
        {name = P[v].w_title, title = P[v].w_title, width = ww, height = (titleHeight + ind *(buttonHeight+buttonGape)+buttonGape), posX = P[v].w_pos.x, posY = P[v].w_pos.y, draggable = true},buttons)
       end
      end
      
      -- Creating the main menu bar window
      local window = WindowLib:new(
        [[<div><svg height="1080" width="3840">
        <text x="]]..((indMMB) * (windowWidth + buttonGape))..[[" y="17" font-size="16" font-family="Play" text-anchor="start" fill="]]..P.MS.BTC.value..[[">DEFAULT-- v]]..script.version..[[ by TheGreatSardini</text>
        </svg></div>
        ]],{name = P.w_title, width = 3840, height = buttonHeight + buttonGape , posX = P.w_pos.x, posY = P.w_pos.y, draggable = false},mainMenuButtons)
     end
    end

    function Help_Menu_Builder()
     if P.w_open == true and P.help_menu.w_open == true then
      local buttons = {}
      local svg = ""
      local ind = 0
      for i, v in ipairs(P.help_menu) do
       if v ~= "separator" then
        local help_button_function = function(v)
         return function()
           P.help_menu.w_html = P.help_menu[v].html
           WindowLib = WLP.init(system)
           Params_Menu_Builder()
           Help_Menu_Builder()
           Cursor_Builder()
           end
        end
        local nb = WindowLib:buttonsNew(P.help_menu[v].name, help_button_function(v), {width = buttonWidth, height = buttonHeight, posX = 5, posY = (titleHeight + 5 + (i-1) * (buttonHeight + buttonGape))})
        ind = ind + 1
        buttons[ind] = nb
       else
        local nb = WindowLib:buttonsNew("", nil, {class= "separator", width = 0, height = 0, posX = 0, posY = (titleHeight + 5 + (i-1) * (buttonHeight + buttonGape))})
        ind = ind + 1
        buttons[ind] = nb
        svg = svg .. [["<line x1="5" y1="]].. 12 + (i-1) * (buttonHeight + buttonGape) ..[[" x2="]]..buttonWidth - 5 ..[[" y2="]].. 12 + (i-1) * (buttonHeight + buttonGape) ..[[" stroke="]]..P.MS.BBC.value..[[" fill="None" stroke-width="0.5"/>"]]
       end
      end
      local ww = 800
      local whtml = P.help_menu.w_html
      local window = WindowLib:new(
      [[<div><svg height="1080" width="1920">
      ]]..svg..whtml..[[
      </svg></div>
      ]],
      {name = P.help_menu.w_title, title = P.help_menu.w_title, width = ww, height = (titleHeight + ind *(buttonHeight+buttonGape)+buttonGape), posX = P.help_menu.w_pos.x, posY = P.help_menu.w_pos.y, draggable = true},buttons)
     end
    end

    function Widgets_Builder()
     if P.w_open == false then
      for i, v in ipairs(customWidgets) do
       if P["Widget_Custom"..i].w_open == true then
        local svg = customWidgets[i]:SVG_Update()
        local bt = customWidgets[i]:getButtons() 
        local nbt = {}
        for i2, v2 in ipairs(bt) do
         nbt[i2] = WindowLib:buttonsNew(v2[1], v2[2], v2[3])
        end
        if #nbt == 0 then nbt = nil end
        local draggable = true
        if customWidgets[i].draggable == 0 then draggable = false end
        local window = WindowLib:new(svg,
         {class = customWidgets[i].class,
         name = P["Widget_Custom"..i].w_title,
         title = customWidgets[i]:getTitle(),
         width = P["Widget_Custom"..i].w_size.x*P["Widget_Custom"..i].w_scale, 
         height = P["Widget_Custom"..i].w_size.y*P["Widget_Custom"..i].w_scale, 
         posX = P["Widget_Custom"..i].w_pos.x, 
         posY = P["Widget_Custom"..i].w_pos.y, 
         draggable = customWidgets[i].draggable,
         fixed = customWidgets[i].fixed},
         nbt)
       end
      end

      if P.Widget_HUD.w_open == true then
       local svg = widget:HUD_Update()
       local window = WindowLib:new(svg,{class = "widgets", name = P.Widget_HUD.w_title, width = P.Widget_HUD.w_size.x*P.Widget_HUD.w_scale, height = P.Widget_HUD.w_size.y*P.Widget_HUD.w_scale, posX = P.Widget_HUD.w_pos.x, posY = P.Widget_HUD.w_pos.y, draggable = true})
      end
      if P.Widget_Platform.w_open == true then
       local svg = widget:Platform_Update()
       local window = WindowLib:new(svg,{class = "widgets", name = P.Widget_Platform.w_title, width = P.Widget_Platform.w_size.x*P.Widget_Platform.w_scale, height = P.Widget_Platform.w_size.y*P.Widget_Platform.w_scale, posX = P.Widget_Platform.w_pos.x, posY = P.Widget_Platform.w_pos.y, draggable = true})
      end
      if P.Widget_Info.w_open == true then
       local svg = widget:Info_Update()
       local window = WindowLib:new(svg,{class = "widgetnopadding", title = "INFO", name = P.Widget_Info.w_title, width = 307*P.Widget_Info.w_scale, height = info_window_height*P.Widget_Info.w_scale, posX = P.Widget_Info.w_pos.x, posY = P.Widget_Info.w_pos.y, draggable = true})
      end
     end
    end
  onStart:
   lua: |
    -- ON START PARAMS --
    function onStartParams()
     system.print("Loading onStartParams")
     hasFinishedLoading = false
     system.showScreen(1)

     info_w_height = 0
     fps = 0
     uCount = 0

     nullvector = vec3(0,0,0)

     cursorX = 860
     cursorY = 440
     cursorWin = ""
     reset = false
     mouseWheel = 0
     mwCLICK = false
     CLICK = false
     CTRL = false
     ALT = false
     SHIFT = false
     GEAR = false

     pitchInput = 0
     rollInput = 0
     yawInput = 0
     brakeInput = 0
     strafeInput = 0
     upInput = 0
     forwardInput = 0
     boosterInput = 0
     ThrottlePos = 0

     previousDeltaY = 0
     previousDeltaX = 0

     xSpeedKPH = 0
     ySpeedKPH = 0
     zSpeedKPH = 0
     xyzSpeedKPH = 0
     velMag = 0
     Az = 0
     Ax = 0
     Ax0 = 0
     Ay0 = 0
     maxAcceleration = 0

     MM = "TRAVEL"
     pkM = true

     VStabPrevAlt = 0
     VStabPrevPosx, VStabPrevPosy, VStabPrevPosz = 0, 0, 0
     targetAutoPitchDeg = 0
     VStabAltLock = nil
     VStabCount = 0
     VStabAdjustedAngle = 0
     SAMflat = false
     turnAssist_toggle = false
     atmoSpeedLock = true

     PKP = ""
     PKPT = 999
     DTK = ""
     Engines = false
     EnginesUpdate = true
     HoverUpdate = true
     VboosterUpdate = true

     landPos = nullvector
     fuelTanksData = {}
     unitData = {}
     aggData = {}
     warpData = {}

     --DRONE
     modeRocket = false
     rocketWarmup = false

     --AUTO LAND
     autoLand = false
     autoStart = false
     autoStartTime = 0
     landTime = 0

     -- BRAKING
     gravityA = 0
     atmosDensity = 0
     LastMaxBrakeInAtmo = 0
     LastMaxBrake = 0
     abvGndDet, abvGndMax = AboveGroundLevel()
     hasGndDet = telemeter ~= nil and type(telemeter) == 'table' and #telemeter > 0 and true or vBooster ~= nil and true or hover ~= nil and true or false
     hasATelemeter = telemeter ~= nil and type(telemeter) == 'table' and #telemeter > 0 and true
     bCM = false -- brake CROSS Mode
     approachSpeed = 0
     approachSpeedZ = 0

     warpInfo = ""
     cWOUPx, cWOUPy, cWOUPz = 0, 0, 0 --getConstructWorldOrientationUp
     cWOFx, cWOFy, cWOFz = 0, 0, 0 --getConstructWorldOrientationForward
     cWORx, cWORy, cWORz = 0, 0, 0 --getConstructWorldOrientationRight

     cOUPx, cOUPy, cOUPz = 0, 0, 0 --getConstructOrientationUp
     cOFx, cOFy, cOFz = 0, 0, 0 --getConstructOrientationForward
     cORx, cORy, cORz = 0, 0, 0 --getConstructOrientationRight

     planetVertSpeedMPS = 0
     cWAVx, cWAVy, cWAVz = 0,0,0

     autoBrake = false

     BackBurn = false
     BackBurnToggle = false
     PreviousACM = nil
     resetingBackBurn = false
     MaxBrakesForce = 0

     parkingModeLockOut = false

     vec2 = require "cpml.vec2"
     if DB ~= nil then
      system.print("Databank found")
      Data = dtbk.new(DB_1)
      system.print("Databank new created")
     else system.print("No Databank linked, please connect one and restart the script!") unit.exit()
     end
     local Atlas = require "atlas"
     Helios = Atlas[0]
     Atlas = nil
     system.print("Atlas loaded")
     Nav = NavigatorPlusPlus.new()
     Nav:buildPIDs()
     system.print("Navigator-- new created")
     widget = WidgetsPlusPlus.new()
     system.print("Widgets-- new created")

     local function pRequire(libName)
      return xpcall( require, system.print, libName)
     end
     customWidgets = {}
     
     for i=1, 25 do
      local fileName = "autoconf.custom.WIDGETS--.widget--custom"..i
      if pRequire(fileName) ~= false then
       require (fileName)
       system.print("Widgets-- Custom"..i.." loaded")
       customWidgets[i] = WidgetsPlusPlusCustom.new(core, unit, (DB ~= nil) and DB or nil, (antigrav ~= nil) and antigrav or nil, (warpdrive ~= nil) and warpdrive or nil, (shield ~= nil) and shield or nil, (switch ~= nil) and switch or nil, player, telemeter)
       P.Widgets_Custom[i] = "w_custom"..i
       P.Widgets_Custom["w_custom"..i] = {name = "CUSTOM 1", value = "None", range = {"Default --", "ALT", "None"}, q = false}
       P.Widgets_Custom["w_custom"..i].name = customWidgets[i]:getName()
       P["Widget_Custom"..i] = {
        w_title = customWidgets[i]:getName(),
        w_pos = customWidgets[i]:getPos(),
        w_size = customWidgets[i]:getSize(),
        w_scale = pcall( function () return type(customWidgets[i]:getScale()) end ) and customWidgets[i]:getScale() or 1,
        w_open = false,
       }
       --system.print(P["Widget_Custom"..i]w_scale)
       system.print("Widgets-- Custom"..i.." new created")
       if type(customWidgets[i].loadData) == 'function' and DB_1 ~= nil then
        customWidgets[i]:loadData()
        system.print("Widgets-- Custom"..i.." data loaded")
       end
      else
       break
      end
     end
     system.print("Finished loading custom widgets: "..#customWidgets)

     WindowLib = WLP.init()
     system.print("winlib-- new created")

     gearExtended = (unit.isAnyLandingGearDeployed() == true)
     if gearExtended then
      unit.deployLandingGears()
     else
      unit.retractLandingGears()
     end
     unit.switchOnHeadlights()
     Nav:updateHovers(upInput,P.ES.hoA.value,P.ES.hoM.value)

     local function decodeJSON(json)
       local decodedInput = string.gsub(json, "%\\u(%x%x%x%x)", function(a) return utf8.char(tonumber(a,16))end)
       return load('return ' .. decodedInput:gsub('[[]', '{'):gsub('[]]', '}'):gsub('"(%w+)":', '["%1"]='))()
      end
     local RemoteControl = false
     local helperId = decodeJSON(unit.getWidgetData())["helperId"] if helperId == nil then helperId = "nan" end
     local name = decodeJSON(unit.getWidgetData())["name"] if name == nil then name = "nan" end
     system.print(tostring(helperId))
     system.print(tostring(name))

     if helperId == "basic_control_unit" or unit.isRemoteControlled() == true then RemoteControl = true end
     if RemoteControl == true then
      player.freeze(1)
      system.print("Is remote controled")
      P.KP.mvL.value = true
      P.KP.mvL.q = true
     end

     local function merge(t1, t2)
      if type(t1) ~= "table" or type(t2)~= "table" then return nil end
      local newT = t1
      local ind = #t1
      for k,v in pairs(t2) do
       ind = ind + 1
       newT[ind] = v
      end 
      return newT
     end
     fueltanks_size = atmofueltank_size + spacefueltank_size + rocketfueltank_size
     fueltanks = {}
     fueltanks = merge(fueltanks,atmofueltank) or fueltanks
     fueltanks = merge(fueltanks,spacefueltank) or fueltanks
     fueltanks = merge(fueltanks,rocketfueltank) or fueltanks
     system.print("Merged fuel tanks")
     prevFTD = 0
    end
  onStart:
   lua: |
    -- Keybinds library --
    local sSS = true
    local tFactor = 1
    local function checkKeybinds(option)
     --system.print("Option "..option)
     if string.sub(P.KP.mouseControlKB.value,-1,-1) == option then
      system.print("Toggling mouse control")
      P.KP.moC.value = not P.KP.moC.value
     elseif string.sub(P.KP.movementLockKB.value,-1,-1) == option then
      system.print("Toggling movement lock")
      P.KP.mvL.value = not P.KP.mvL.value
     elseif string.sub(P.KP.viewLockKB.value,-1,-1) == option then
      system.print("Toggling view lock")
      P.KP.viL.value = not P.KP.viL.value
     elseif string.sub(P.KP.flightModeKB.value,-1,-1) == option then
      if P.KP.flM.value == "CRUISE" then
        setControlMasterMode("TRAVEL")
      elseif P.KP.flM.value == "TRAVEL" then
        setControlMasterMode("CRUISE")
      end
     elseif string.sub(P.KP.altitudeAP.value,-1,-1) == option then
      if hasAtmosphere and inAtmo and not HoldAltitude then
       HoldAltitude = spaceEngineMinAltitude - 0.01*noAtmosphericDensityAltitude
       system.print("Altitude Locked to 11% atmo.")
      elseif HoldAltitude then 
       system.print("Altitude Unlocked.")
       HoldAltitude = nil
      end
      return
     elseif string.sub(P.KP.speedLockKB.value,-1,-1) == option then
      atmoSpeedLock = not atmoSpeedLock
      if atmoSpeedLock == true then Nav:setAtmoMaxSpeed(P.ES.aMS.value) system.print("Atmospheric speed limit activated")
      else Nav:setAtmoMaxSpeed(49999) system.print("Atmospheric speed limit deactivated") end
     elseif string.sub(P.KP.showScreenKB.value,-1,-1) == option then
      system.print("Toggling system.showScreen")
      sSS = not sSS
      if sSS == true then system.showScreen(1) else system.showScreen(0) end
     end
     updateParams()
    end
    
    function keyBindsOnStartControl(action)
     if action == 'option1' then
      P.w_open = not P.w_open
      P.QuickToolBar.w_open = false
      if P.w_open == false then
       windowsHide()
      else windowsShow() end
      ALT = false
     elseif action == 'option2' then
      -- TODO use this?
     elseif action == 'option3' then
      checkKeybinds("3")
     elseif action == 'option4' then
      checkKeybinds("4")
     elseif action == 'option5' then
      checkKeybinds("5")
     elseif action == 'option6' then
      checkKeybinds("6")
     elseif action == 'option7' then
      checkKeybinds("7")
     elseif action == 'option8' then
      checkKeybinds("8")
     elseif action == 'option9' then
      checkKeybinds("9")
     elseif action ~= 'lalt' and action ~= 'lshift' and not (action == 'brake' and velMag < 1) and action ~= 'gear' then 
      enginesToggle()
     end
     if P.w_open == true then
      system.showHelper(0)
      if action == 'stopengines' or action == 'leftmouse' then
       WindowLib:toggleClick(true)
      elseif action == 'brake' then
       CTRL = true
      end
     elseif P.QuickToolBar.w_open == true then
      system.showHelper(0)
      if action == 'stopengines' or action == 'leftmouse' then
       WindowLib:toggleClick(true)
      end
     elseif MM == "CRUISE" or MM == "TRAVEL" then
      if action == 'forward' then
       pitchInput = -1
      elseif action == 'backward' then
       pitchInput = 1
      elseif action == 'yawright' then
       if P.KP.iCo.value == false then
       yawInput = -1 else rollInput = 1 end
      elseif action == 'yawleft' then
       if P.KP.iCo.value == false then
       yawInput = 1 else rollInput = -1 end
      elseif action == 'right' then
       if P.KP.iCo.value == false then
       rollInput = 1 else yawInput = -1 end
      elseif action == 'left' then
       if P.KP.iCo.value == false then
       rollInput = -1 else yawInput = 1 end
      elseif action == 'brake' then
       if DTK ~= "brake" and Nav:getMasterMode() == "CRUISE" then
        if Nav:getThrottleValue() > constants.epsilon then
         Nav:updateThrottleValue(-0.5)
        end
       end
      end
     elseif MM == "PLATFORM" then
      if action == 'stopengines' then
       if pkM then modeRocket = false else modeRocket = not modeRocket end
      elseif action == 'forward' then
       forwardInput = 1
      elseif action == 'backward' then
       forwardInput = -1
      elseif action == 'yawright' then
       yawInput = -1
      elseif action == 'yawleft' then
       yawInput = 1
      elseif action == 'right' then
       strafeInput = 1
      elseif action == 'left' then
       strafeInput = -1
      end
     elseif MM == "DRONE" then
      if action == 'speedup' then
       --TODO What to do here?
       system.print("Bla")
      elseif action == 'speeddown' then
       --TODO What to do here?
      elseif action == 'stopengines' then
       if pkM then modeRocket = false else modeRocket = not modeRocket end
       if modeRocket then self.warmup = true else self.warmup = false VStabAltLock = nil end
      elseif action == 'forward' then
       pitchInput = -1
      elseif action == 'backward' then
       pitchInput = 1
      elseif action == 'yawright' then
       if P.KP.iCo.value == false then
       yawInput = -1 else rollInput = 1 end
      elseif action == 'yawleft' then
       if P.KP.iCo.value == false then
       yawInput = 1 else rollInput = -1 end
      elseif action == 'right' then
       if P.KP.iCo.value == false then
       rollInput = 1 else yawInput = -1 end
      elseif action == 'left' then
       if P.KP.iCo.value == false then
       rollInput = -1 else yawInput = 1 end
      end     
     end

     -- Shared Actions for all Modes --
     if P.w_open == false and P.QuickToolBar.w_open == false then
      if PKP == action and currentTime - PKPT < P.KP.dTT.value then 
       DTK = action 
       --system.print("Double tap: "..action) 
      end
      PKP = action
      PKPT = currentTime
      --system.print(action.."|"..MM)

      if action == 'speedup' then
       tFactor = 1
       Nav:updateThrottleValue(0.1)
      elseif action == 'speeddown' then
       tFactor = 1
       Nav:updateThrottleValue(-0.1)
      elseif action == 'stopengines' then
       if Nav:getThrottleValue() == 0 then
        Nav:setThrottleValue(49999)
       else
        Nav:resetThrottleValue()
        Nav:setThrottleValue(0)
       end
       mwCLICK = true
       autoLand, autoStart = false,false
       HoldAltitude = nil
      elseif action == 'forward' then
       autoLand, autoStart = false,false
       modeRocket = false
       HoldAltitude = nil
      elseif action == 'backward' then
       autoLand, autoStart = false,false
       modeRocket = false
       HoldAltitude = nil
      elseif action == 'yawright' then
      elseif action == 'yawleft' then
      elseif action == 'right' then
       autoLand, autoStart = false,false
      elseif action == 'left' then
       autoLand, autoStart = false,false
      elseif action == 'straferight' then
       strafeInput = 1
       autoLand, autoStart = false,false
       modeRocket = false
      elseif action == 'strafeleft' then
       strafeInput = -1
       autoLand, autoStart = false,false
       modeRocket = false
      elseif action == 'up' then
       upInput = 1
       Nav:updateHovers(upInput,nil,P.ES.hoM.value)
       autoLand, autoStart = false,false
       HoldAltitude = nil
      elseif action == 'down' then
       upInput = -1
       Nav:updateHovers(upInput,nil,P.ES.hoM.value)
       autoLand, autoStart = false,false
       HoldAltitude = nil
       landTime = time
      elseif action == 'lshift' then
       SHIFT = true
      elseif action == 'lalt' then
       system.showHelper(0)
       ALT = true
       if DTK == 'lalt' then
        P.QuickToolBar.w_open = true
        windowsShow()
       end
      elseif action == 'brake' then
       brakeInput = 1
       autoLand, autoStart = false,false
       modeRocket = false
       HoldAltitude = nil
       --if ALT then Engines = false; updateParams() end
       --TODO remove this? or keep?
      elseif action == 'gear' then
       GEAR = true
       modeRocket = false
       HoldAltitude = nil
       toggleLandingGearCheck()
       if geL then 
        if not withinParkingRange() or autoLand or DTK == 'gear' or P.KP.flM.value == "DRONE" or P.KP.flM.value == "PLATFORM" then 
         enableAutoLand()
        else
         setParkingMode(not pkM)
         parkingModeLockOut = not pkM
        end
       else
        if withinParkingRange() and Engines == false then
         enginesToggle()
         enableAutoStart()
        else
         enableAutoLand()
        end
       end
      elseif action == 'light' then
       if unit.isAnyHeadlightSwitchedOn() == true then
        unit.switchOffHeadlights()
       else
        unit.switchOnHeadlights()
       end
      elseif action == 'booster' then
      elseif action == 'antigravity' then
       if antigrav ~= nil then antigrav.toggle() end
      elseif action == 'groundaltitudedown' then
       P.ES.hoA.value = P.ES.hoA.value - 1
       Nav:updateHovers(upInput,P.ES.hoA.value,P.ES.hoM.value)
       if HoldAltitude then tFactor = 1; HoldAltitude = HoldAltitude - 10 end
      elseif action == 'groundaltitudeup' then
       P.ES.hoA.value = P.ES.hoA.value + 1
       Nav:updateHovers(upInput,P.ES.hoA.value,P.ES.hoM.value)
       if HoldAltitude then tFactor = 1; HoldAltitude = HoldAltitude + 10 end
      elseif action == 'warp' then
      end
     end
    end

    function keyBindsOnStopControl(action)
     if action ~= nil then
     end
     if action == DTK then 
      --system.print("Double tap released: "..DTK) 
      DTK = "" 
     end
     if P.w_open == true then
      if action == 'stopengines' or action == 'leftmouse' then
       WindowLib:toggleClick(false)
      elseif action == 'brake' then
       CTRL = false
      end
     elseif P.QuickToolBar.w_open == true then
      system.showHelper(1)
      if action == 'stopengines' or action == 'leftmouse' then
       WindowLib:toggleClick(false)
      elseif action == 'lalt' then
       P.QuickToolBar.w_open = false
       ALT = false
       windowsHide()
      end
     elseif (action ~= 'lshift' and (SHIFT == false or SHIFT == true and P.KP.shL.value == false) and (MM == "CRUISE" or MM == "TRAVEL"))
      or MM == "DRONE" then
      if action == 'stopengines' then
       mwCLICK = false
      elseif action == 'forward' then
       pitchInput = 0
      elseif action == 'backward' then
       pitchInput = 0
      elseif action == 'yawright' then
       if P.KP.iCo.value == false then
       yawInput = 0 else rollInput = 0 end
      elseif action == 'yawleft' then
       if P.KP.iCo.value == false then
       yawInput = 0 else rollInput = 0 end
      elseif action == 'right' then
       if P.KP.iCo.value == false then
       rollInput = 0 else yawInput = 0 end
      elseif action == 'left' then
       if P.KP.iCo.value == false then
       rollInput = 0 else yawInput = 0 end
      elseif action == 'straferight' then
       strafeInput = 0
      elseif action == 'strafeleft' then
       strafeInput = 0
      elseif action == 'up' then 
       upInput = 0
       Nav:updateHovers(upInput,P.ES.hoA.value,P.ES.hoM.value)
      elseif action == 'down' then
       upInput = 0
       Nav:updateHovers(upInput,P.ES.hoA.value,P.ES.hoM.value)
      elseif action == 'brake' then
       brakeInput = 0
      elseif action == 'gear' then
       GEAR = false
      elseif action == 'light' then
      elseif action == 'booster' then
      elseif action == 'antigravity' then
      elseif action == 'warp' then
      elseif action == 'lshift' then
       SHIFT = false
      elseif action == 'lalt' then
       ALT = false
      end
     elseif MM == "PLATFORM" then
      if action == 'stopengines' then
       mwCLICK = false
      elseif action == 'forward' then
       forwardInput = 0
      elseif action == 'backward' then
       forwardInput = 0
      elseif action == 'yawright' then
       yawInput = 0
      elseif action == 'yawleft' then
       yawInput = 0
      elseif action == 'right' then
       strafeInput = 0
      elseif action == 'left' then
       strafeInput = 0
      elseif action == 'straferight' then
       strafeInput = 0
      elseif action == 'strafeleft' then
       strafeInput = 0
      elseif action == 'up' then
       upInput = 0
       Nav:updateHovers(upInput,P.ES.hoA.value,P.ES.hoM.value)
      elseif action == 'down' then
       upInput = 0
       Nav:updateHovers(upInput,P.ES.hoA.value,P.ES.hoM.value)
      elseif action == 'brake' then
       brakeInput = 0
      elseif action == 'lshift' then
       SHIFT = false
      elseif action == 'lalt' then
       ALT = false
      end
     elseif action == 'lshift' then SHIFT = false
     end
    end

    function keyBindsOnLoopControl(action)
     if action ~= nil then
      --system.print('on action loop: '..action)
     end
     if action ~= 'lshift' and SHIFT == false then
      if MM == "CRUISE" or MM == "TRAVEL" then
       if action == 'speedup' then
        tFactor = tFactor + 0.1
        Nav:updateThrottleValue(0.02*tFactor)
       elseif action == 'speeddown' then
        tFactor = tFactor + 0.1
        Nav:updateThrottleValue(-0.02*tFactor)
       elseif action == 'brake' then
        if DTK ~= "brake" and Nav:getMasterMode() == "CRUISE" then
         if Nav:getThrottleValue() > constants.epsilon then
          Nav:updateThrottleValue(-0.05)
         end
        end
       elseif action == 'booster' then
       end
      end
      if action == 'down' then
       checkLanded()
      elseif action == 'groundaltitudeup' then
       if HoldAltitude then tFactor = tFactor + 0.1; HoldAltitude = HoldAltitude + (5 * tFactor) end
      elseif action == 'groundaltitudedown' then
       if HoldAltitude then tFactor = tFactor + 0.1; HoldAltitude = HoldAltitude - (5 * tFactor) end
      end
     end
    end
    
  onStart:
   lua: |
    -- Divers Functions --
    function getGlobals()
     currentWorldPos = vec3(construct.getWorldPosition())
     closestPlanetIndex = 0
     local planetDistance = 999999999999
     for i, v in pairs(Helios) do
      if (currentWorldPos - vec3(v.center)):len() < planetDistance then
       planetDistance = (currentWorldPos - vec3(v.center)):len()
       closestPlanetIndex = i
      end
     end
     planet = Helios[closestPlanetIndex]
     currentPlanetName = planet.name[1]
     currentPlanetRadius = planet.radius --TODO Remove?
     currentPlanetCenter = planet.center
     currentPlanetGM = planet.GM
     currentPlanetMaxStatic = planet.maxStaticAltitude
     hasAtmosphere = planet.hasAtmosphere
     local altTable = { [1]=6637, [2]=3426, [4]=7580, [26]=4242, [27]=4150, [3]=21452, [6]=4498, [7]=6285, [8]=3434, [9]=5916 } -- Measured min space engine altitudes for: Madis, Alioth, Talemai, Sanctuary, Haven, Sicari, Sinnen, Thades, Teoma, Jago
     spaceEngineMinAltitude = altTable[planet.id] or 0.5353125*(planet.atmosphereThickness)
     noAtmosphericDensityAltitude = planet.atmosphereThickness or 0


     local function vectorLen(x,y,z)
      return math.sqrt(x * x + y * y + z * z)
     end
     local cWCOM = construct.getWorldCenterOfMass()
     local cWCOMx, cWCOMy, cWCOMz = cWCOM[1], cWCOM[2], cWCOM[3]
     local cPCx, cPCy, cPCz = currentPlanetCenter[1], currentPlanetCenter[2], currentPlanetCenter[3]
     alt = vectorLen(cWCOMx-cPCx, cWCOMy-cPCy, cWCOMz-cPCz) - planet.radius or 0

     --TODO Fix this
     inspace = 0
     atmosDensity = unit.getAtmosphereDensity()
     inAtmo = false or (alt < noAtmosphericDensityAltitude and atmosDensity > 0.00001 )
     if atmosDensity < 0.075 then
      inspace = 1
     end
     
     MM = Nav:getMasterMode()
     coreMass = construct.getTotalMass()
    end

    function paramsSetColorsRange()
     for i, v in ipairs (P.MS) do
      if type(P.MS[v]) == "table" then
       if P.MS[v].value then
        if type( P.MS[v].value) == "string" and v ~= "PRESET" and v ~= "HELP_MENU" then
         for k, l in ipairs (webColors.namedColors) do
          P.MS[v].range[#P.MS[v].range+1] = l
         end
        end
       end
      end
     end
    end


    function checkWidgets()
     hideAllDefaultWidgets()
     -- SPEEDOMETER 
     if P.w_open == false then
      -- HUD
      if P.WS.w_hud.value == "None" then
       P.Widget_HUD.w_open = false
      else
       P.Widget_HUD.w_open = true
      end

      -- Info
      if P.WS.w_info.value == "None" then
       P.Widget_Info.w_open = false
      else
       P.Widget_Info.w_open = true
      end

      -- Platform
      if P.WS.w_platform.value == "None" then
       P.Widget_Platform.w_open = false
      else
       P.Widget_Platform.w_open = true
      end

      -- SPEEDO
      if P.WS.w_speedometer.value == "Default" then
       if unit then unit.showWidget() end
      end

      -- GYRO
      if P.WS.w_gyro.value == "Default" then
       if gyro then gyro.showWidget() end
      end

      -- FUEL
      if P.WS.w_fuel.value == "Default" then
       if atmofueltank then
        if atmofueltank_size > 0 then
         _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, L_TEXT("ui_lua_w_atmofuel", "Atmo Fuel"), "fuel_container")
        end
       end
       if spacefueltank then
        if spacefueltank_size > 0 then
         _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, L_TEXT("ui_lua_w_spacefuel", "Space Fuel"), "fuel_container")
        end
       end
       if rocketfueltank then
        if rocketfueltank_size > 0 then
         _autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, L_TEXT("ui_lua_w_rocketfuel", "Rocket Fuel"), "fuel_container")
        end
       end
      end

      -- CORE
      if (P.WS.w_core.value == "Default" and ALT == false) or (P.WS.w_core.value == "ALT" and ALT == true)then
       if core then core.showWidget() end
      end

      -- RADAR
      if (P.WS.w_radar.value == "Default" and ALT == false) or (P.WS.w_radar.value == "ALT" and ALT == true)then
       if #radar ~= 0 then
        _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
       end
      end

      -- PERISCOPE
      if (P.WS.w_periscope.value == "Default" and ALT == false) or (P.WS.w_periscope.value == "ALT" and ALT == true)then
       if #radar ~= 0 then
        local rdr = radar_1.getOperationalState() == 1 and {radar_1} or {radar_2} or {radar_1}
        if rdr then _autoconf.displayCategoryPanel(rdr, 1, L_TEXT("ui_lua_w_periscope", "Periscope"), "periscope") end
       end
      end

      -- AGG
      if (P.WS.w_agg.value == "Default" and ALT == false) or (P.WS.w_agg.value == "ALT" and ALT == true)then
       if antigrav then antigrav.showWidget() end
      end

      -- WARP
      if (P.WS.w_warp.value == "Default" and ALT == false) or (P.WS.w_warp.value == "Auto" and warpData.Info:lower() == "activate warp") or (P.WS.w_warp.value == "ALT" and ALT == true)then
       if warpdrive then warpdrive.showWidget() end
      end

      -- PARENTING
      if (P.WS.w_parenting.value == "Default" and ALT == false) or (P.WS.w_parenting.value == "ALT" and ALT == true)then
       parentingPanelId = system.createWidgetPanel("Docking")
       parentingWidgetId = system.createWidget(parentingPanelId,"parenting")
       system.addDataToWidget(unit.getDataId(),parentingWidgetId)
      end

      -- COMBAT STRESS
      if (P.WS.w_cstress.value == "Default" and ALT == false) or (P.WS.w_cstress.value == "ALT" and ALT == true)then
       coreCombatStressPanelId = system.createWidgetPanel("Core combat stress")
       coreCombatStressgWidgetId = system.createWidget(coreCombatStressPanelId,"core_stress")
       system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)
      end

      -- SHIELD
      if (P.WS.w_shield.value == "Default" and ALT == false) or (P.WS.w_shield.value == "ALT" and ALT == true) then
       if shield then shield.showWidget() end
      end

      for i, v in ipairs(P.Widgets_Custom) do
       if (P.Widgets_Custom["w_custom"..i].value == "Default --" and ALT == false) or (P.Widgets_Custom["w_custom"..i].value == "ALT" and ALT == true) then
        P["Widget_Custom"..i].w_open = true
       elseif P.Widgets_Custom["w_custom"..i].value == "None" or (P.Widgets_Custom["w_custom"..i].value == "ALT" and ALT == false) then
        P["Widget_Custom"..i].w_open = false
       end
      end
     end
    end

    function hideAllDefaultWidgets()
     if core then core.hideWidget() end
     if unit then unit.hideWidget() end
     if gyro then gyro.hideWidget() end
     if antigrav then antigrav.hideWidget() end
     if warpdrive then warpdrive.hideWidget() end
     if shield then shield.hideWidget() end
     _autoconf.hideCategoryPanels()
     system.destroyWidgetPanel(parentingPanelId)
     system.destroyWidgetPanel(coreCombatStressPanelId)
    end

    function windowsShow()
     system.lockView(1)
     player.freeze(1)
     WindowLib = WLP.init(system)
     checkWidgets()
     Cursor_Builder()
     Params_Menu_Builder()
     Help_Menu_Builder()
     Widgets_Builder()
     Quick_Menu_Builder()
    end

    function windowsHide()
     if P.KP.mvL.value == false then player.freeze(0) else player.freeze(1) end
     if P.KP.viL.value == false then system.lockView(0) else system.lockView(1) end
     WindowLib = WLP.init()
     checkWidgets()
     Params_Menu_Builder()
     Help_Menu_Builder()
     Widgets_Builder()
     Quick_Menu_Builder()
     Cursor_Builder()
    end

    function setParamsFuelTanks()
     for i, v in ipairs(fuelTanksData) do
      P["Widget_FuelTank_"..i] = {
       w_title = "FUEL TANK "..i,
       w_pos = {x=150+i*99, y=150},
       w_open = false,
       w_scale = 1.5
       }
     end
    end

    function enginesToggle()
     if P.ES.eng.value == "AUTO" then 
      if Engines == false then
       Engines = true
       system.print("Engines ON")
      end
     elseif P.ES.eng.value == "OFF" and Engines == true then
      Engines = false
      system.print("Engines OFF")
     elseif P.ES.eng.value == "ON" and Engines == false then
      Engines = true
      system.print("Engines ON")
     end
    end

    function setControlMasterMode(mode)
     Nav:setMasterMode(mode)
     if mode ~= P.KP.flM.value then
      P.KP.flM.value = mode--Nav:getMasterMode()
      system.print(mode.." mode set")
     end
    end

    --TC  = TITLE_COLOR
    --TCA = TITLE_COLOR_A
    --TTC = TITLE_TEXT_COLOR
    --WC  = WN_COLOR
    --WCA = WN_COLOR_A
    --WTC = WN_TEXT_COLOR
    --BC  = BUTTON_COLOR
    --BBC = BUTTON_BORDER_COLOR
    --BCA = BUTTON_COLOR_A
    --BTC = BUTTON_TEXT_COLOR
    --wTC = WIDGET_TEXT_COLOR
    --wAC = WIDGET_ANIM_COLOR
    --WFC = WIDGET_FIXED_COLOR

    colorPresets = {
     preset0 = {TC = "olive",
      TCA = 1,
      TTC = "black",
      WC = "dimgray",
      WCA = 0.9,
      WTC = "gold",
      BC = "navajowhite",
      BBC = "darkslategray",
      BCA = 0.4,
      BTC = "saddlebrown",
      wTC = "gold",
      wAC = "burlywood",
      WFC = "olive",
      },
     preset1 = {TC = "white",
      TCA = 1,
      TTC = "black",
      WC = "midnightblue",
      WCA = 0.4,
      WTC = "skyblue",
      BC = "white",
      BBC = "lightgray",
      BCA = 0.1,
      BTC = "white",
      wTC = "skyblue",
      wAC = "red",
      WFC = "white",
      },
     preset2 = {TC = "yellowgreen",
      TCA = 1,
      TTC = "black",
      WC = "dimgrey",
      WCA = 0.8,
      WTC = "greenyellow",
      BC = "lightgrey",
      BBC = "lightgrey",
      BCA = 0.3,
      BTC = "white",
      wTC = "greenyellow",
      wAC = "greenyellow",
      WFC = "lightgrey",
      },
     preset3 = {TC = "black",
      TCA = 0.5,
      TTC = "chartreuse",
      WC = "black",
      WCA = 0.1,
      WTC = "chartreuse",
      BC = "black",
      BBC = "chartreuse",
      BCA = 0.3,
      BTC = "chartreuse",
      wTC = "chartreuse",
      wAC = "chartreuse",
      WFC = "chartreuse",
      },
     preset4 = {TC = "darkorange",
      TCA = 0.6,
      TTC = "yellow",
      WC = "black",
      WCA = 0.5,
      WTC = "yellow",
      BC = "darkorange",
      BBC = "darkorange",
      BCA = 0.5,
      BTC = "yellow",
      wTC = "yellow",
      wAC = "yellow",
      WFC = "darkorange",
      },
     preset5 = {TC = "black",
      TCA = 0,
      TTC = "white",
      WC = "black",
      WCA = 0,
      WTC = "white",
      BC = "black",
      BBC = "white",
      BCA = 0,
      BTC = "white",
      wTC = "white",
      wAC = "white",
      WFC = "white",
      },
     }

    function saveColorPreset()
     for k, l in pairs(P.MS) do
      if type(l) == "table" and l.value ~= nil and k ~= "PRESET" and k ~= "HELP_MENU" then
       colorPresets[previousPreset][k] = P.MS[k].value
      end
     end
     
    end

    function loadColorPreset()
     for k, l in pairs(P.MS) do
      if type(l) == "table" and l.value ~= nil and k ~= "PRESET" and k ~= "HELP_MENU" then
       P.MS[k].value = colorPresets[P.MS.PRESET.value][k]
      end
     end
     previousPreset = P.MS.PRESET.value
    end

    function updateParams()
     setControlMasterMode(P.KP.flM.value)
     EnginesUpdate = true
     HoverUpdate = true
     VboosterUpdate = true
     if Nav:getAtmoMaxSpeed() ~= P.ES.aMS.value and atmoSpeedLock == true then
      Nav:setAtmoMaxSpeed(P.ES.aMS.value)
     end
     if gyro then
      if P.ES.gyr.value == "ON" and gyro.isActive() == false then gyro.activate()
      elseif P.ES.gyr.value == "OFF" and gyro.isActive() == true then gyro.deactivate()
      end
     elseif P.ES.gyr.value ~= "OFF" then
      P.ES.gyr.value = "OFF"
      system.print("No Gyro attached. Resetting gyr")
     end
     updateGyro()
     if antigrav then antigrav.setTargetAltitude(P.ES.agA.value) end
     Nav:updateHovers(upInput,P.ES.hoA.value,P.ES.hoM.value)
     saveColorPreset()
     loadColorPreset()
     unit.setTimer("SCREEN",P.WS.w_refresh.value)
     if P.KP.mvL.value == false then player.freeze(0) else player.freeze(1) end
     if P.KP.viL.value == false then system.lockView(0) else system.lockView(1) end
     Nav:buildPIDs()
    end

    function updateGyro()
     if gyro then
      if P.ES.gyr.value == "ON" and gyro.isActive() == false then gyro.activate()
      elseif P.ES.gyr.value == "OFF" and gyro.isActive() == true then gyro.deactivate()
      elseif P.ES.gyr.value == "CROSS" then
       if bCM and gyro.isActive() ~= true then 
        gyro.activate()
        system.print("turn ON gyro")
       elseif not bCM and gyro.isActive() == true then
        gyro.deactivate()
        system.print("turn off gyro is now="..tostring(gyro.isActive()))
       end
      end
     elseif P.ES.gyr.value ~= "OFF" then
      P.ES.gyr.value = "OFF"
      system.print("No Gyro attached. Resetting gyr")
     end
    end

    function updateGear()
     if hasGndDet then
      toggleLandingGearCheck() -- can't be called from flush
     end
    end

    function withinParkingRange()
     return hasGndDet and abvGndDet < abvGndMax and abvGndDet > 0
    end
    
    function setParkingMode(pm)
     pkM = pm == true and true or false 
     local mode = nil
     if pkM and P.KP.pkM.value ~= "OFF" then 
      mode = P.KP.pkM.value
     else
      mode = P.KP.flM.value
     end
     if mode ~= Nav:getMasterMode() then
      Nav:setMasterMode(mode)
     end
    end
    
    function parkingEligible()
      return P.KP.pkM.value ~= "OFF" and P.KP.flM.value ~= "PLATFORM" and P.KP.flM.value ~= "DRONE"
    end
    
    local lPx, lPy, lPz = 0,0,0
    function checkLanded()
     local dist = math.abs(vectorLen(cWPx, cWPy, cWPz) - vectorLen(lPx, lPy, lPz))
     if currentTime - landTime > 0.5 
     and dist < 0.1 
     and accMag < 0.1 
     and Engines == true 
     then
      if P.ES.eng.value == "AUTO" then
       system.print("Switching off eng")
       Engines = false
       autoLand = false
       updateParams()
      elseif autoLand then
       system.print("Auto Land Completed")
       autoLand = false
       updateParams()
      end
     elseif dist >= 0.1 then
      lPx, lPy, lPz = cWPx, cWPy, cWPz
      landTime = currentTime
     else
      --
     end
    end

    function enableAutoLand()
     if autoLand then return end
     autoLand = true; autoStart = false
     system.print('Auto landing mode activated')
     if hasGndDet == false then system.print("WARNING no telemeter detected! Crash landing") end
     landTime = currentTime
    end

    function enableAutoStart()
     if autoStart then return end
     autoStart = true; autoLand = false
     autoStartTime = time
     system.print('Auto start eng activated')
    end
    
    function toggleLandingGearCheck()
     if hasGndDet == false then -- no ground detection, manually toggle
      gearExtended = not gearExtended
      if gearExtended then
       unit.deployLandingGears()
      else
       unit.retractLandingGears()
      end
     else -- has ground detection, auto choose when
      if not parkingModeLockOut and abvGndDet < abvGndMax and abvGndDet > 0 and (velMag < 28 or autoLand) and not gearExtended then
       gearExtended = true
       unit.deployLandingGears()
      elseif ((velMag >= 28 and not autoLand) or abvGndDet == -1 or abvGndDet >= abvGndMax or parkingModeLockOut) and gearExtended then
       gearExtended = false
       unit.retractLandingGears()
      end
     end
    end

    function updateHelpMenu()
     P.help_menu.Info_Page.html = help.info
     P.help_menu.MS.html = help.menuSettings
     P.help_menu.ES.html = help.engineSettings
     P.help_menu.AS.html = help.autopilotSettings
     P.help_menu.WS.html = help.widgets
     P.help_menu.KP.html = help.keybingParams
     P.help_menu.QuickToolBar.html = help.q
     P.help_menu.w_html = P.help_menu.Info_Page.html
    end

    local cos, sin, max, min = math.cos, math.sin, math.max, math.min
    function convertToWorldCoordinates(posString)
     local num = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'
     local posPattern = '::pos{' .. num .. ',' .. num .. ',' .. num .. ',' .. num .. ',' .. num .. '}'
     local systemId, bodyId, latitude, longitude, altitude = string.match(posString,posPattern)
     systemId = tonumber(systemId)
     bodyId = tonumber(bodyId)
     latitude = tonumber(latitude)
     longitude = tonumber(longitude)
     altitude = tonumber(altitude)
     if tonumber(bodyId) == 0 then
      return latitude,longitude,altitude
     end
     latitude = 0.0174532925199 * max(min(latitude, 90), -90)
     longitude = 0.0174532925199 * (longitude % 360)
     local center, radius = Helios[bodyId].center, tonumber(Helios[bodyId].radius)
     local xproj = cos(latitude)
     local px, py, pz = center[1]+(radius+altitude) * xproj*cos(longitude),
          center[2]+(radius+altitude) * xproj*sin(longitude),
          center[3]+(radius+altitude) * sin(latitude)
     return px, py, pz
    end

    function stringToTable(String, Separator)
     local Separator = Separator or ','
     local axes = {}
     for axis in String:gmatch('[^'..Separator..']+') do
      axes[#axes + 1] = axis
     end
     return axes
    end

    function mouseControlUpdate()
     system.lockView(1)
     if system.getMouseDeltaY() ~= 0 or previousDeltaY ~= 0 then 
      pitchInput = system.getMouseDeltaY() * P.KP.mCS.value *-0.25
      previousDeltaY = pitchInput
     end
     if system.getMouseDeltaX() ~= 0 or previousDeltaX ~= 0 then 
      yawInput = system.getMouseDeltaX() * P.KP.mCS.value *-0.25
      previousDeltaX = yawInput
     end
    end

  onStart:
   lua: |
    local abs, floor, asin, sqrt, cos, acos, sin, deg, atan, rad, sign, clamp, rad2deg, max, ceil = math.abs, math.floor, math.asin, math.sqrt, math.cos, math.acos, math.sin, math.deg, math.atan, math.rad, utils.sign, utils.clamp, constants.rad2deg, math.max, math.ceil
    -- Thrust Management library --
    function vectorLen(x,y,z)
     return sqrt(x*x+y*y+z*z)
    end
    
    function brakingCalculation()
     local MaxBrakesForce = construct.getMaxBrake() or 0
     local maxSpeed = 50000*0.27777777777
     local cAV = construct.getVelocity()
     local cAVx, cAVy, cAVz = cAV[1], cAV[2], cAV[3]
     local cWAV = construct.getWorldAbsoluteVelocity()
     local velMag = sqrt(cAVx^2+cAVy^2+cAVz^2)
     local cM = construct.getTotalMass()
     local forwardEnginesForce, backwardEnginesForce = Nav:getMaxKPA()
     local gravityV = core.getWorldGravity()
     local g = core.getGravityIntensity()
     local G_axis = -1*utils.sign(cWAV[1]*gravityV[1] + cWAV[2]*gravityV[2] + cWAV[3]*gravityV[3])
     local brakesAcceleration = MaxBrakesForce + g*G_axis * cM
     local forwardAcceleration = forwardEnginesForce + g*G_axis * cM
     local backwardAcceleration = backwardEnginesForce + g*G_axis * cM
     local forwardBrakeDistance = cM * maxSpeed^2 / (brakesAcceleration + backwardAcceleration/2) * (1 - sqrt(1 - ((velMag)^2 / maxSpeed^2)))
     local backburnBrakeDistance = cM * maxSpeed^2 / (brakesAcceleration + forwardAcceleration/2) * (1 - sqrt(1 - ((velMag)^2 / maxSpeed^2)))
     return forwardBrakeDistance, backburnBrakeDistance
    end

    function sf(s)
     return string.format("%.4f", s)
    end
    function normalizeVec(x,y,z)
     local l = sqrt(x*x + y*y + z*z)
     return x/l, y/l, z/l
    end
    local function dotVec(x1,y1,z1,x2,y2,z2)
     return x1*x2 + y1*y2 + z1*z2
    end

    local function multiplyVec(x,y,z,factor)
     return x*factor, y*factor, z*factor
    end
  
    local function world2local(x,y,z)
     local v = library.systemResolution3({cWORx, cWORy, cWORz},{cWOFx, cWOFy, cWOFz},{cWOUPx, cWOUPy, cWOUPz},{x,y,z})
     return v[1],v[2],v[3]
    end

    local function rotateVec(vx, vy, vz, phi, ax, ay, az)
     local l = sqrt(ax*ax + ay*ay + az*az)
     local ux, uy, uz = ax/l, ay/l, az/l
     local c, s = cos(phi), sin(phi)
     local m1x, m1y, m1z = (c + ux * ux * (1-c)), (ux * uy * (1-c) - uz * s), (ux * uz * (1-c) + uy * s)
     local m2x, m2y, m2z = (uy * ux * (1-c) + uz * s), (c + uy * uy * (1-c)), (uy * uz * (1-c) - ux * s)
     local m3x, m3y, m3z = (uz * ux * (1-c) - uy * s), (uz * uy * (1-c) + ux * s), (c + uz * uz * (1-c))
     return m1x*vx+m1y*vy+m1z*vz, m2x*vx+m2y*vy+m2z*vz, m3x*vx+m3y*vy+m3z*vz
    end

    local function cross(x, y, z, vx, vy, vz)
     return y*vz - z*vy, z*vx - x*vz, x*vy - y*vx
    end

    -- Rotations control --
    local function getConstructRot(x, y, z)
     if x == nil then x, y, z = -1,0,0 end
     x, y, z = normalizeVec(x,y,z)
     local CRx, CRy, CRz = cWORx, cWORy, cWORz
     local CUx, CUy, CUz = cWOUPx, cWOUPy, cWOUPz
     local cx, cy, cz = cross(x, y, z, CUx, CUy, CUz)
     local rAx, rAy, rAz = normalizeVec(cx, cy, cz) -- rot axis
     local ConstructRot = acos(clamp(dotVec(rAx, rAy, rAz,CRx, CRy, CRz), -1, 1)) * rad2deg
     cx, cy, cz = cross(rAx, rAy, rAz, CRx, CRy, CRz)
     if dotVec(cx, cy, cz, CUx, CUy, CUz) < 0 then ConstructRot = -ConstructRot end
     return ConstructRot
    end

    local function getConstructPitch(x, y, z)
     if x == nil then x, y, z = 0,0,1 end
     x, y, z = normalizeVec(x,y,z)
     local CRx, CRy, CRz = cWORx, cWORy, cWORz
     local CFx, CFy, CFz = cWOFx, cWOFy, cWOFz
     local cx, cy, cz = cross(x, y, z, CRx, CRy, CRz)
     local pAx, pAy, pAz = normalizeVec(cx, cy, cz) --pitch axis
     local ConstructPitch = acos(clamp(dotVec(pAx, pAy, pAz, CFx, CFy, CFz), -1, 1)) * rad2deg
     cx, cy, cz = cross(pAx, pAy, pAz, CFx, CFy, CFz)
     if dotVec(cx, cy, cz, CRx, CRy, CRz) < 0 then ConstructPitch = -ConstructPitch end
     return ConstructPitch
    end

    local function getConstructRoll(x,y,z)
     if x == nil then x, y, z = 0,0,1 end
     x, y, z = normalizeVec(x,y,z)
     local CRx, CRy, CRz = cWORx, cWORy, cWORz
     local CFx, CFy, CFz = -cWOFx, -cWOFy, -cWOFz
     local cx, cy, cz = cross(x, y, z, CFx, CFy, CFz)
     local rAx, rAy, rAz = normalizeVec(cx, cy, cz) --roll Axis
     local ConstructRoll = acos(clamp(dotVec(rAx, rAy, rAz, CRx, CRy, CRz), -1, 1)) * rad2deg
     cx, cy, cz = cross(rAx, rAy, rAz, CRx, CRy, CRz)
     if dotVec(cx, cy, cz, CFx, CFy, CFz) < 0 then ConstructRoll = -ConstructRoll end
     return ConstructRoll
    end
    
    local function getConstructRoll90(x,y,z) --for the auto yaw when pitch = 90
     if x == nil then x, y, z = 0,0,1 end
     x, y, z = normalizeVec(x,y,z)
     local CRx, CRy, CRz = cWORx, cWORy, cWORz
     local CUx, CUy, CUz = -cWOUPx, -cWOUPy, -cWOUPz
     local cx, cy, cz = cross(x, y, z, CUx, CUy, CUz)
     local rAx, rAy, rAz = normalizeVec(cx, cy, cz) --roll Axis
     local ConstructRoll = acos(clamp(dotVec(rAx, rAy, rAz, CRx, CRy, CRz), -1, 1)) * rad2deg
     cx, cy, cz = cross(rAx, rAy, rAz, CRx, CRy, CRz)
     if dotVec(cx, cy, cz, CUx, CUy, CUz) < 0 then ConstructRoll = -ConstructRoll end
     return ConstructRoll
    end

    local function rollAngularVelocity90(x,y,z, angle, speed) --for the auto yaw when pitch = 90
     if x == nil then x, y, z = 0,0,1 end
     x, y, z = normalizeVec(x,y,z)
     local CUx, CUy, CUz = -cWOUPx, -cWOUPy, -cWOUPz
     if angle ~= 0 then x, y, z = rotateVec(x, y, z, rad(-angle), CUx, CUy, CUz) end
     local RollDeg = getConstructRoll90(x, y, z)
     if (RollPID90 == nil) then 
      RollPID90 = pid.new(0.05, 0, 1)
     end
     RollPID90:inject(0 - RollDeg)
     local PIDget = RollPID90:get()
     return PIDget * CUx * speed, PIDget * CUy * speed, PIDget * CUz * speed
    end

    local function rollAngularVelocity(x,y,z, angle, speed)
     if x == nil then x, y, z = 0,0,1 end
     x, y, z = normalizeVec(x,y,z)
     local CFx, CFy, CFz = -cWOFx, -cWOFy, -cWOFz
     if angle ~= 0 then x, y, z = rotateVec(x, y, z, rad(-angle), CFx, CFy, CFz) end
     local RollDeg = getConstructRoll(x, y, z)
     local PIDget = 0-RollDeg*0.05*speed
     return PIDget * CFx, PIDget * CFy, PIDget * CFz
    end

    local function pitchAngularVelocity(x,y,z, angle, speed)
     if x == nil then x, y, z = 0,0,1 end
     x, y, z = normalizeVec(x,y,z)
     local CRx, CRy, CRz = cWORx, cWORy, cWORz
     if angle ~= 0 then x, y, z = rotateVec(x, y, z, rad(-angle), CRx, CRy, CRz) end
     local PitchDeg = getConstructPitch(x, y, z)
     local PIDget = 0-PitchDeg*0.05*speed
     return PIDget * CRx, PIDget * CRy, PIDget * CRz
    end

    local function yawAngularVelocity(x,y,z, angle, speed)
     if x == nil then x, y, z = -1,0,0 end
     x, y, z = normalizeVec(x,y,z)
     local CUx, CUy, CUz = cWOUPx, cWOUPy, cWOUPz
     if angle ~= 0 then x, y, z = rotateVec(x, y, z, rad(angle), CUx, CUy, CUz) end
     local YawDeg = getConstructRot(x, y, z)
     local PIDget = 0-YawDeg*0.5*speed
     return PIDget * CUx, PIDget * CUy, PIDget * CUz
    end

    local function getAAR(ox, oy, oz, nx, ny, nz, px, py, pz)
     ox, oy, oz = normalizeVec(ox, oy, oz)
     nx, ny, nz = normalizeVec(nx, ny, nz)
     local ax, ay, az = cross(ox, oy, oz, nx, ny, nz)
     local axisLen = vectorLen(ax, ay, az)
     local angle = 0
     ax, ay, az = normalizeVec(ax, ay, az)
     if axisLen > 0.000001
     then
      angle = asin(clamp(axisLen, 0, 1))
     else
      ax, ay, az = px, py, pz
     end
     if dotVec(ox, oy, oz, nx, ny, nz) < 0
     then
      angle = math.pi - angle
     end
     return ax, ay, az, angle
    end

    function round(num, numDecimalPlaces) -- rounds variable num to numDecimalPlaces
     local mult = 10 ^ (numDecimalPlaces or 0)
     return floor(num * mult + 0.5) / mult
    end

    local lastG = 0
    local lastVel = 0
    local function RefreshLastMaxBrake()
     local gravityR = round(gravityA, 5) -- round to avoid insignificant updates
     local speedR = round(velMag)
     if lastG == nil or lastG ~= gravityR or lastVel ~= speedR then
      local maxBrake = construct.getMaxBrake()
      if maxBrake ~= nil and maxBrake > 0 and inAtmo then 
       maxBrake = maxBrake / clamp(speedR/100, 0.1, 1) / atmosDensity
       if atmosDensity > 0.10 then 
        LastMaxBrakeInAtmo = maxBrake 
       end
      end
      if maxBrake ~= nil and maxBrake > 0 then
       LastMaxBrake = maxBrake
      end
      lastG = gravityR
      lastVel = speedR
     end
    end

    local lastvgd = -1
    local lasthgd = -1
    function AboveGroundLevel()
     local function hoverDetectGround()
      local vGndDist,vGndMax,hGndDist,hGndMax = -1,-1,-1,-1
      if vBooster then
       vGndDist = vBooster.getDistance()
       vGndMax = vBooster.getMaxDistance()
       if vGndDist > -1 and vGndDist < 0.01 then vGndDist = lastvgd else lastvgd = vGndDist end
      end
      if hover then
       hGndDist = hover.getDistance()
       hGndMax = hover.getMaxDistance()
       if hGndDist > -1 and hGndDist < 0.01 then hGndDist = lasthgd else lasthgd = hGndDist end
      end
      if vGndDist ~= -1 and hGndDist ~= -1 then
       if vGndDist < hGndDist then
        return vGndDist, math.max(vGndMax,hGndMax)
       else
        return hGndDist, math.max(vGndMax,hGndMax)
       end
      elseif vGndDist ~= -1 then
       return vGndDist, vGndMax
      elseif hGndDist ~= -1 then
       return hGndDist, hGndMax
      else
       return -1, math.max(vGndMax,hGndMax)
      end
     end
     local hovGndDet, hovGndMax = hoverDetectGround() 
     local telGndDet = -1
     local cAV = construct.getVelocity()
     local velMag = vectorLen(cAV[1], cAV[2], cAV[3])
     if telemeter_1 then 
      telGndDet = telemeter_1.raycast().distance
      if telGndDet == 0 then telGndDet = -1 end
     end
     if hovGndDet > 0.2 and telGndDet ~= -1 then
      if hovGndDet < telGndDet then 
       return hovGndDet, hovGndMax
      else
       return telGndDet, hovGndMax
      end
     elseif telGndDet ~= -1 then
      return telGndDet, hovGndMax
     else
      return hovGndDet, hovGndMax
     end
    end

    local lastApTickTime = system.getArkTime()
    local deltaTick = 0
    local brakingLastTime = lastApTickTime
    local brakingLastSpd = 0
    local brakingLastGnd = -1
    local landSpeed = -1
    local StopDistance = -1
    local minFallSpeed = -1

    --Braking Counters--
    local lastBTime
    local lastBVel

    -- Auto Park --
    local autoPark = false

    function thrustManager()
     time = system.getArkTime()
     deltaTick = time - lastApTickTime
     lastApTickTime = time
     if deltaTick < 0.004 then return end

     -- Final inputs --
     local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
     local finalRollInput = rollInput + system.getControlDeviceYawInput()
     local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
     local finalRotationInput = finalPitchInput + finalRollInput + finalYawInput

     -- Globals --
     local cWOUP = construct.getWorldOrientationUp()
     local cWOF = construct.getWorldOrientationForward()
     local cWOR = construct.getWorldOrientationRight()
     local cOUP = construct.getOrientationUp()
     local cOF = construct.getOrientationForward()
     local cOR = construct.getOrientationRight()
     if bCM and gyro.isActive() == true then
      cWOUPx, cWOUPy, cWOUPz = cWOR[1], cWOR[2], cWOR[3]
      cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]
      cWORx, cWORy, cWORz = -cWOUP[1], -cWOUP[2], -cWOUP[3]
      --local
      cOUPx, cOUPy, cOUPz = cOR[1], cOR[2], cOR[3]
      cOFx, cOFy, cOFz = cOF[1], cOF[2], cOF[3]
      cORx, cORy, cORz = -cOUP[1], -cOUP[2], -cOUP[3]
     else
      cWOUPx, cWOUPy, cWOUPz = cWOUP[1], cWOUP[2], cWOUP[3]
      cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]
      cWORx, cWORy, cWORz = cWOR[1], cWOR[2], cWOR[3]
      --local
      cOUPx, cOUPy, cOUPz = cOUP[1], cOUP[2], cOUP[3]
      cOFx, cOFy, cOFz = cOF[1], cOF[2], cOF[3]
      cORx, cORy, cORz = cOR[1], cOR[2], cOR[3]
     end
     atmosDensity = unit.getAtmosphereDensity()
     gravityA = core.getGravityIntensity()

     -- Flush Variables --
     local cWP = construct.getWorldPosition()
     cWPx, cWPy, cWPz = cWP[1], cWP[2], cWP[3]
     local cWCOM = construct.getWorldCenterOfMass()
     local cWCOMx, cWCOMy, cWCOMz = cWCOM[1], cWCOM[2], cWCOM[3]
     local gravityV = core.getWorldGravity()
     local gx, gy, gz = gravityV[1], gravityV[2], gravityV[3]
     local cAV = construct.getVelocity()
     local cAVx, cAVy, cAVz = cAV[1], cAV[2], cAV[3]
     local cWAV = construct.getWorldVelocity()
     cWAVx, cWAVy, cWAVz = cWAV[1], cWAV[2], cWAV[3]
     local WAFA = construct.getWorldAirFrictionAcceleration()
     local WAFAx, WAFAy, WAFAz = WAFA[1], WAFA[2], WAFA[3]
     local cWAngV = construct.getWorldAngularVelocity()
     local cWAngVx, cWAngVy, cWAngVz = cWAngV[1], cWAngV[2], cWAngV[3]
     local wAFAA = construct.getWorldAirFrictionAngularAcceleration()
     local wAFAAx, wAFAAy, wAFAAz = wAFAA[1], wAFAA[2], wAFAA[3]
     local cMAS = construct.getMaxAngularSpeed()
     local cWA = construct.getWorldAcceleration()

     local cPCx, cPCy, cPCz = currentPlanetCenter[1], currentPlanetCenter[2], currentPlanetCenter[3]
     local wVx, wVy, wVz = cWCOMx-cPCx, cWCOMy-cPCy, cWCOMz-cPCz --world vertical
     local cWAVDirx, cWAVDiry, cWAVDirz = normalizeVec(cWAVx,cWAVy,cWAVz)
     velMag = vectorLen(cAVx, cAVy, cAVz) --xyzSpeedMPS
     accMag = vectorLen(cWA[1], cWA[2], cWA[3])
     xyzSpeedKPH = velMag*3.6
     xSpeedKPH = dotVec(cWAVx, cWAVy, cWAVz, cWORx, cWORy, cWORz)*3.6
     ySpeedKPH = dotVec(cWAVx, cWAVy, cWAVz, cWOFx, cWOFy, cWOFz)*3.6
     zSpeedKPH = dotVec(cWAVx, cWAVy, cWAVz, cWOUPx, cWOUPy, cWOUPz)*3.6
     --local xySpeedKPH = sqrt(xSpeedKPH^2+ySpeedKPH^2)
     planetVertSpeedMPS = dotVec(cWAVx, cWAVy, cWAVz, normalizeVec(wVx, wVy, wVz))
     local planetLatSpeedMPS = sqrt(vectorLen(cWAVx, cWAVy, cWAVz)^2-planetVertSpeedMPS^2)
     alt = vectorLen(cWCOMx-cPCx, cWCOMy-cPCy, cWCOMz-cPCz) - planet.radius or 0

   
     Ax0 = 0 --pitch angle in deg
     Ay0 = 0 --roll angle in deg
     if alt < P.AS.stA.value then
      Ax0 = getConstructPitch(wVx, wVy, wVz)
      Ay0 = getConstructRoll(wVx, wVy, wVz)
     end

     Az = deg(atan(xSpeedKPH, ySpeedKPH)) -- drift rot angle in deg
     Ax = deg(atan(zSpeedKPH, ySpeedKPH)) -- drift pitch angle in deg

     ThrottlePos = (Nav:getThrottleValue() ~= nil) and Nav:getThrottleValue() or 0
     

     -- Ground Detection --
     if hasGndDet then
      abvGndDet, abvGndMax = AboveGroundLevel()

      -- Parking Mode --
      local parkingRange = abvGndDet < abvGndMax and abvGndDet > 0 and xyzSpeedKPH < P.AS.aBS.value
      local noInputs = finalPitchInput==0 and finalRollInput==0 and finalYawInput==0 and upInput==0 and not modeRocket and not autoLand

      if parkingEligible() and ThrottlePos == 0 then
       if parkingRange then
        if not parkingModeLockOut and noInputs then
         setParkingMode(true)
        end
       else --not in range
        parkingModeLockOut = false
       end
      else --not eligible
       parkingModeLockOut = false
       setParkingMode(false)
      end

      -- Turn on brakeCrossMode --
      if 
      P.ES.gyr.value == "CROSS" 
      and gyro 
      and abvGndDet < 100 and abvGndDet > 0
      and (autoLand or brakeInput > 0)
      then -- prerequisites for turning on bCM
       local downVel = dotVec(cWAVx,cWAVy,cWAVz,-cWOUPx,-cWOUPy,-cWOUPz)
       local limitB, limitT = approachSpeedZ > 0 and approachSpeedZ or 2, approachSpeedZ+10
       if downVel > limitT and downVel > 15 then
        bCM = true
       elseif bCM and downVel < limitB then
        bCM = false
       end
      elseif bCM then
       bCM = false
      end

      if (time - brakingLastTime > 0.5 or abs(brakingLastGnd - abvGndDet) > 2)then
       -- update approach speed based on stop distance --
       RefreshLastMaxBrake()
       local fUP = Nav:maxForceUp()*0.5
       local cOUP = {cOUPx, cOUPy, cOUPz}
       local maxKinematicGnd = construct.getMaxThrustAlongAxis("ground", cOUP)[1]
       local gDist = abvGndDet ~= -1 and abvGndDet*clamp(P.AS.aLR.value-0.1,0.1,1) or hasATelemeter and 101 or abvGndMax > 0 and abvGndMax

       local delayDist = 0.1 * velMag
       local dist      = gDist-P.AS.grO.value-delayDist
       local final      = 0.1
       local mass      = coreMass
       local thrust     = fUP
       local hov   = maxKinematicGnd
       local hoverDist    = abvGndMax-P.AS.grO.value
       local maxBrakeForce  = LastMaxBrakeInAtmo
       local atmosDensity  = clamp(atmosDensity,0.4,2) --0.994
       local gravityA    = gravityA --9.8893
       local zAxis      = true
       approachSpeedZ = Kinematic.maxInitialVelocity(dist,final,mass,thrust,hov,hoverDist,maxBrakeForce,atmosDensity,gravityA,zAxis)
       if P.ES.gyr.value == "CROSS" then
        zAxis      = false
        approachSpeed = Kinematic.maxInitialVelocity(dist,final,mass,thrust,hov,hoverDist,maxBrakeForce,atmosDensity,gravityA,zAxis)
       end 
       landSpeed = P.ES.gyr.value == "CROSS" and approachSpeed > 2 and -approachSpeed or approachSpeedZ > 2 and -approachSpeedZ or -(2+gDist*0.1)

       brakingLastTime = time
       brakingLastGnd = abvGndDet
      end
     else
      pkM = false
      approachSpeed = 0
      approachSpeedZ = 0
     end
     MM = Nav:getMasterMode()

     if Engines == true then
      -- Starting Values

      if MM == "CRUISE" or MM == "TRAVEL" then
       -- Atuopilot rotations --
       if P.AS.anS.value == true and abs(Az) > 35 and ySpeedKPH > 50 and ySpeedKPH > zSpeedKPH and inspace == 0 and abs(Ax0) < 30 and abs(Ay0) < 30 then
        finalYawInput = finalYawInput * -0.1
       end
      end

      if MM == "DRONE" then
       --P.AS.iAB.value = false
       P.KP.shL.value = false
      end      

      -- Control Keys Rotation --
      --TODO Does drone mode work with mouse control?
      local tAVx, tAVy, tAVz = 0,0,0
      local pFact = finalPitchInput * cMAS * P.ES.pSF.value
      local rFact = finalRollInput * cMAS * P.ES.rSF.value
      local yFact = finalYawInput  * cMAS * P.ES.ySF.value
      if MM == "DRONE" and modeRocket == true then
       tAVx = rFact * cWOFx + yFact * -cWOFx
       tAVy = rFact * cWOFy + yFact * -cWOFy
       tAVz = rFact * cWOFz + yFact * -cWOFz
      elseif MM == "DRONE" and modeRocket == false then
       tAVx = yFact * cWOUPx
       tAVy = yFact * cWOUPy
       tAVz = yFact * cWOUPz
      else
       tAVx = pFact * cWORx + rFact * cWOFx + yFact * cWOUPx
       tAVy = pFact * cWORy + rFact * cWOFy + yFact * cWOUPy
       tAVz = pFact * cWORz + rFact * cWOFz + yFact * cWOUPz
      end

      -- THRUST COMPOSER --
      local longBx, longBy, longBz = 0, 0, 0 --longitudinal brake
      local latBx, latBy, latBz = 0, 0, 0 --lateral brake
      local vertBx, vertBy, vertBz = 0, 0, 0 --vertical brake
      local brakeAx, brakeAy, brakeAz = 0, 0, 0 --brake acceleration
      local longAx, longAy, longAz = 0, 0, 0 --longitudinal acceleration
      local latAx, latAy, latAz = 0, 0, 0 --lateral acceleration
      local vertAx, vertAy, vertAz = 0, 0, 0 --vertical acceleration
      autoBrake = false
      local strafeSpeed = unitData.maxSpeedkph
      local targetLongSpeed, targetLatSpeed, targetVertSpeed = 0,0,0

      -- Auto Rotations --
      if autoLand == true and MM ~= "DRONE"then
       local rAVx, rAVy, rAVz = rollAngularVelocity(wVx, wVy, wVz, 0, P.ES.rSF.value)
       local pAVx, pAVy, pAVz = pitchAngularVelocity(wVx, wVy, wVz, 0 , P.ES.pSF.value)
       tAVx = tAVx + pAVx + rAVx
       tAVy = tAVy + pAVy + rAVy
       tAVz = tAVz + pAVz + rAVz
      elseif MM == "CRUISE" or MM == "TRAVEL" then
       -- Pitch and roll stabilization
       if alt < P.AS.stA.value then
        if P.AS.auR.value == true 
         and abs(Ay0 + P.ES.rAd.value*-1) > 0.25
         and finalRollInput == 0 and abs(Ax0) < 30
         and turnAssist_toggle == false
         and abs(Ay0 + P.ES.rAd.value) < P.AS.tAR.value then
         local rAVx, rAVy, rAVz = rollAngularVelocity(wVx, wVy, wVz, 0 - P.ES.rAd.value, P.ES.rSF.value)
         tAVx = tAVx + rAVx
         tAVy = tAVy + rAVy
         tAVz = tAVz + rAVz
        end
        
        if xyzSpeedKPH > 100 and HoldAltitude ~= nil then
         VStabAltLock = floor(HoldAltitude)
         local pitchOffset = clamp(((alt - HoldAltitude)+(planetVertSpeedMPS*4))*0.05,-30,30)
         local pAVx, pAVy, pAVz = pitchAngularVelocity(wVx, wVy, wVz, pitchOffset + P.ES.pAd.value, P.ES.pSF.value)
         tAVx = tAVx + pAVx
         tAVy = tAVy + pAVy
         tAVz = tAVz + pAVz
        elseif P.AS.auP.value == true 
         and abs(Ax0) < (P.AS.aPA.value + abs(P.ES.pAd.value))
         and finalPitchInput == 0 
         and upInput == 0 
         and turnAssist_toggle == false
         and abs(Ax0) < 45 
         and abs(Ay0) < 10
         then

         -- auP alt Stabilization
         if xyzSpeedKPH > 250 and P.AS.atS.value == true then
          if VStabAltLock == nil and abs(Ax0) < 0.05 then 
           VStabAltLock = floor(alt)
           system.print("Altitude locked at: "..VStabAltLock)
          end
         else VStabAltLock = nil
         end
         local pAVx, pAVy, pAVz = pitchAngularVelocity(wVx, wVy, wVz, 0 + P.ES.pAd.value, P.ES.pSF.value)
         tAVx = tAVx + pAVx
         tAVy = tAVy + pAVy
         tAVz = tAVz + pAVz
        else if VStabAltLock ~= nil then VStabAltLock = nil system.print("Pitch stabilisation unlocked") end
        end

        -- Turn assist
        if P.AS.tuA.value == true 
         and abs(Ay0) > P.AS.tAR.value
         and abs(Ax0) < P.AS.tAP.value
         and finalPitchInput == 0
         and finalYawInput == 0
         and finalRollInput == 0
         and inspace == 0 
         then
         turnAssist_toggle = true
         if (TApitchPID == nil) then 
          TApitchPID = pid.new(0.2, 0, 10)
         end
         TApitchPID:inject(0 - Ax0)
         local PIDget = TApitchPID:get()
         local pAAx, pAAy, pAAz = PIDget * cWORx, PIDget * cWORy, PIDget * cWORz
         --targetAngularVelocity = cWOUP * 0.25 * sign(Ay0) * -1 + pitchAngularAcceleraion
         tAVx = cWOUPx * 0.25 * sign(Ay0) + pAAx
         tAVy = cWOUPy * 0.25 * sign(Ay0) + pAAy
         tAVz = cWOUPz * 0.25 * sign(Ay0) + pAAz
        else turnAssist_toggle = false
        end
       end

       -- BackBurn --
       if finalYawInput == 0 and finalPitchInput == 0 and finalRollInput == 0
        and (DTK == "brake" or BackBurnToggle == true) then
        local SBBMinimumSpeed = 1000
        if MM ~= "CRUISE" then
         PreviousMasterMode = "TRAVEL"
         Nav:setMasterMode("CRUISE")
        end
        -- Space BackBurn --
        if xyzSpeedKPH > SBBMinimumSpeed and not inAtmo then 
         BackBurnToggle = true
         if Az == 0 then
          finalYawInput = 1
         else
          local axx, axy, axz, an = getAAR(-1*cWOFx, -1*cWOFy, -1*cWOFz, cWAVx, cWAVy, cWAVz, 0, 0, 0)
          if (BBPID == nil) then
           BBPID = pid.new(0.2, 0, 10)
          end
          BBPID:inject(an)
          local PIDget = BBPID:get()
          tAVx = axx * PIDget
          tAVy = axy * PIDget
          tAVz = axz * PIDget
          ThrottlePos = 0
          oWVx, oWVy, oWVz = cWAVx, cWAVy, cWAVz
         end
        -- Continue BackBurn --
        elseif (DTK == "" and BackBurnToggle == true) or (xyzSpeedKPH < SBBMinimumSpeed and BackBurnToggle == true) then
         local axx, axy, axz, an = getAAR(cWOFx, cWOFy, cWOFz, oWVx, oWVy, oWVz, 0,0,0)
         if (BBPID == nil) then
          BBPID = pid.new(0.2, 0, 10)
         end
         BBPID:inject(an)
         local PIDget = BBPID:get()
         tAVx = axx * PIDget
         tAVy = axy * PIDget
         tAVz = axz * PIDget
         ThrottlePos = 0
        end
       elseif (finalYawInput ~= 0 or finalPitchInput ~= 0 or finalRollInput ~= 0 or DTK ~= "brake")
        and BackBurnToggle == true then
        BackBurnToggle = false
        if PreviousMasterMode == "TRAVEL" then 
         Nav:setMasterMode("TRAVEL") 
        end
        ThrottlePos = 0
        Nav:resetThrottleValue()
       end

       -- Prograde --
       if not inAtmo 
        and finalRotationInput == 0
        and BackBurnToggle == false
        and P.AS.aPG.value == true
        and xyzSpeedKPH > 200
        then
        local axx, axy, axz, an = getAAR(cWOFx, cWOFy, cWOFz, cWAVx, cWAVy, cWAVz, 0, 0, 0)
        if (APGPID == nil) then
         APGPID = pid.new(0.05, 0, 1)
        end
        APGPID:inject(an)
        local PIDget = APGPID:get()
        tAVx = axx * PIDget
        tAVy = axy * PIDget
        tAVz = axz * PIDget
       end
      elseif MM == "PLATFORM" and alt < P.AS.stA.value then
       --Roll stabilisation
       local autoRollRollThreshold = 0.1
       if abs(Ay0) > autoRollRollThreshold then
        local rAVx, rAVy, rAVz = rollAngularVelocity(wVx, wVy, wVz, 0 - P.ES.rAd.value, 1)
        tAVx = tAVx + rAVx
        tAVy = tAVy + rAVy
        tAVz = tAVz + rAVz
       end

       --Pitch stabilisation
       local aPA = 90
       if abs(Ax0) < aPA then
        local pAVx, pAVy, pAVz = pitchAngularVelocity(wVx, wVy, wVz, 0 + P.ES.pAd.value, 1)
        tAVx = tAVx + pAVx
        tAVy = tAVy + pAVy
        tAVz = tAVz + pAVz
       end
      elseif MM == "DRONE" and modeRocket == true then
       --if not custPID then custPID = pid3.new(1,0,1,1,-20,10) end --custPID:reset()
       local pitchOffset = 90 + (-upInput * 30)
       if upInput ~= 0 then
       else
        if not prevAltHoldAng then prevAltHoldAng = -4.8 end
        local aAdj = prevAltHoldAng
        if xyzSpeedKPH > 100 and HoldAltitude ~= nil then
         VStabAltLock = floor(HoldAltitude)
         if abs(alt - HoldAltitude) < 50 then aAdj = prevAltHoldAng + clamp(planetVertSpeedMPS,-1,1)/1000 end
         VStabAltLock = floor(HoldAltitude)
         pitchOffset = pitchOffset + clamp(((alt - HoldAltitude)+(planetVertSpeedMPS*4))*0.05,-30,30) + aAdj
        else
         aAdj = prevAltHoldAng + clamp(planetVertSpeedMPS,-1,1)/1000
         pitchOffset = pitchOffset + clamp(planetVertSpeedMPS/10,-30,30) + aAdj
        end
        prevAltHoldAng = aAdj
       end

       local pAVx, pAVy, pAVz = pitchAngularVelocity(wVx, wVy, wVz, pitchOffset + P.ES.pAd.value, P.ES.pSF.value*0.5)
       tAVx = tAVx + pAVx
       tAVy = tAVy + pAVy
       tAVz = tAVz + pAVz
     
       if Ax0 < -45 and Ax0 > -135 then --auto yaw (roll) to stay flat
        local rAVx, rAVy, rAVz = rollAngularVelocity90(wVx, wVy, wVz, 0, 1)
        tAVx = tAVx + rAVx
        tAVy = tAVy + rAVy
        tAVz = tAVz + rAVz
       end
      elseif MM == "DRONE" and modeRocket == false then
       -- BackBurn --
       if finalYawInput == 0 and finalPitchInput == 0 and finalRollInput == 0 and upInput <= 0
        and P.AS.bBu.value == true 
        --and (DTK == "brake" or BackBurnToggle == true) 
        then

        local axx, axy, axz, an = 0,0,0,0
        local nwVx, nwVy, nwVz = normalizeVec(wVx, wVy, wVz) -- normalized world vector (negative grav.)
        local ncWAVx, ncWAVy, ncWAVz = normalizeVec(cWAVx, cWAVy, cWAVz)
        local vAngle = acos(dotVec(ncWAVx, ncWAVy, ncWAVz, nwVx, nwVy, nwVz) / (vectorLen(ncWAVx, ncWAVy, ncWAVz) * vectorLen(nwVx, nwVy, nwVz)))*rad2deg
        if vAngle < 15 and planetVertSpeedMPS > 9 then 
         local ux, uy, uz = multiplyVec(-gx,-gy,-gz,1)
         axx, axy, axz, an = getAAR(cWOUPx, cWOUPy, cWOUPz, cWAVx+ux, cWAVy+uy, cWAVz+uz, 0, 0, 0)
        else
         local ux, uy, uz = multiplyVec(gx,gy,gz,1.8)
         axx, axy, axz, an = getAAR(-cWOUPx, -cWOUPy, -cWOUPz, cWAVx+ux, cWAVy+uy, cWAVz+uz, 0, 0, 0)
        end
        local aFact = clamp(an*rad2deg/40,-1,1) -- 40 = less sensitive
        tAVx = axx * aFact
        tAVy = axy * aFact
        tAVz = axz * aFact

       else
        -- Stabilization & Drone Rolling --
        local angF = SHIFT == true and P.ES.dSA.value or P.ES.dCA.value
        local rAVx, rAVy, rAVz = rollAngularVelocity(wVx, wVy, wVz, 0 + finalRollInput * angF, P.ES.rSF.value)
        local pAVx, pAVy, pAVz = pitchAngularVelocity(wVx, wVy, wVz, 0 - finalPitchInput * angF , P.ES.pSF.value)
        tAVx = tAVx + pAVx + rAVx
        tAVy = tAVy + pAVy + rAVy
        tAVz = tAVz + pAVz + rAVz
       end
      end

      -- Longitudinal Translation
      if MM == "PLATFORM" then 
       if pkM then
        if SHIFT == false then 
         strafeSpeed = P.KP.pMS.value
         targetLongSpeed = forwardInput * P.KP.pMS.value
        else
         targetLongSpeed = forwardInput * unitData.maxSpeedkph
        end
       else
        if modeRocket == true then 
         targetLongSpeed = unitData.maxSpeedkph
        else
         targetLongSpeed = forwardInput * unitData.maxSpeedkph
        end
       end
      end
      
      if MM == "CRUISE" or MM == "TRAVEL" or MM == "PLATFORM" then
       -- Auto Orbit Speed --
       --TODO make orbiting possible for platform mode? and drone Mode?
       if P.AS.atS.value == true and P.AS.aOS.value == true and not inAtmo and ThrottlePos ~= 0 and VStabAltLock ~= nil then
        ThrottlePos = sqrt(currentPlanetGM / (alt + planet.radius))*3.6
       end

       if xyzSpeedKPH > 10000 then
        if strafeInput == 0 then
         targetLatSpeed = xSpeedKPH
        end
        if upInput == 0 then
         targetVertSpeed = zSpeedKPH
        end
       else
        targetLatSpeed = strafeInput*strafeSpeed
        targetVertSpeed = VStabAltLock ~= nil and VStabAltLock-alt or upInput*strafeSpeed
       end
      end

      if MM == "DRONE" and modeRocket == true then
       if abs(Ax0) > 85 then rocketWarmup = false end
       if rocketWarmup then
        targetVertSpeed = P.ES.aMS.value * (abs(Ax0)/90)
       else
        targetVertSpeed = P.ES.aMS.value
       end
      elseif MM == "DRONE" and modeRocket == false then
       local nwVx, nwVy, nwVz = normalizeVec(wVx, wVy, wVz) -- normalized world vector (negative grav.)
       local wLx, wLy, wLz = cross(nwVx, nwVy, nwVz, cWOUPx, cWOUPy, cWOUPz) -- world left
       local wFx, wFy, wFz = normalizeVec(cross(-nwVx, -nwVy, -nwVz, wLx, wLy, wLz)) -- world forward (forward perpendicular to grav.)
       local cFx, cFy, cFz = normalizeVec(cross(wLx, wLy, wLz, cWOUPx, cWOUPy, cWOUPz)) -- construct forward

       local fGA = dotVec(gx, gy, gz, cFx, cFy, cFz) -- forward grav. acceleration (my forward engine)
       local fAirA = dotVec(WAFAx, WAFAy, WAFAz, cFx, cFy, cFz) -- forward air resistance acceleration
       local fTotA = fGA + fAirA -- forward total acceleration
       local fS = dotVec(cWAVx, cWAVy, cWAVz, cFx, cFy, cFz) -- forward speed

       -- Angle from world vertical (radians)
       local fAngle = acos(dotVec(cWOUPx, cWOUPy, cWOUPz, nwVx, nwVy, nwVz) / (vectorLen(cWOUPx, cWOUPy, cWOUPz) * vectorLen(nwVx, nwVy, nwVz)))
       local adjacent = fTotA + fS
       local hyp = adjacent/math.cos(fAngle)
       local tVx, tVy, tVz = multiplyVec(wFx, wFy, wFz, hyp) -- scale to max grav. thrust

       -- Downinput shifts vector down
       local downInput = upInput < 0 and abs(upInput) or 0 -- downInput
       local dVx, dVy, dVz = multiplyVec(-nwVx, -nwVy, -nwVz, downInput*(abs(planetVertSpeedMPS)+hyp+50))
       local tVx, tVy, tVz = tVx+dVx, tVy+dVy, tVz+dVz -- add downinput vector

       -- Convert back to local coords
       local tLVx, tLVy, tLVz = world2local(tVx, tVy, tVz)
       targetLatSpeed, targetLongSpeed, targetVertSpeed = multiplyVec(tLVx, tLVy, tLVz, 3.6) -- convert to kph

       -- MODIFIERS --
       local ncWAVx, ncWAVy, ncWAVz = normalizeVec(cWAVx, cWAVy, cWAVz)
       local VvsNZang = acos(dotVec(-cWOUPx, -cWOUPy, -cWOUPz, ncWAVx, ncWAVy, ncWAVz) / (vectorLen(-cWOUPx, -cWOUPy, -cWOUPz) * vectorLen(ncWAVx, ncWAVy, ncWAVz)))*rad2deg
       --angle between velocity vector and -z axis (when to brake)
       if brakeInput == 1 
        or finalYawInput == 0 and finalPitchInput == 0 and finalRollInput == 0 and upInput == 0 and (
         VvsNZang < 95 or VvsNZang > 165 or xyzSpeedKPH < 0.01
        )
       then
        targetLatSpeed, targetLongSpeed, targetVertSpeed = 0,0,0
       end
     
       local targetForwardSpeed = dotVec(tVx, tVy, tVz, cFx, cFy, cFz)
       local targetForwardAcceleration = targetForwardSpeed - fS
       local forwardRemainingAcceleration = fTotA - targetForwardAcceleration

       -- only up, not down input --
       local extraVertSpeed = upInput > 0 and upInput*strafeSpeed or 0
       targetVertSpeed = targetVertSpeed + extraVertSpeed
      end

      local overRide = false
      if autoLand == true then
       overRide = true
       targetLongSpeed = 0
       ThrottlePos = 0
       Nav:resetThrottleValue()
       Nav:setThrottleValue(0)
       targetLatSpeed = 0

       -- Calculate Approach Speed --
       if hasGndDet == false then 
        targetVertSpeed = -10 -- crash landing
       else
        if abvGndDet > -1 then --I sense the ground
         if abvGndDet < P.AS.grO.value then -- close
          targetVertSpeed = -2*3.6 * P.AS.aLR.value
         else -- ratio of distance left
          targetVertSpeed = landSpeed * 0.9 * 3.6 * P.AS.aLR.value
         end
        else -- can't detect the ground
         if alt - currentPlanetMaxStatic > 200 then --accelerate
          targetVertSpeed = -5000
         else
          targetVertSpeed = landSpeed * 3.6 * P.AS.aLR.value
         end
        end
       end

       checkLanded()-- turn off Engines when stopped
      elseif autoStart == true then
       overRide = true
       targetLongSpeed = 0
       ThrottlePos = 0
       Nav:resetThrottleValue()
       Nav:setThrottleValue(0)
       targetLatSpeed = 0
       if time - autoStartTime < 2 then
        targetVertSpeed = 10
       else
        autoStart = false
       end
      end


      if MM == "DRONE" or MM == "PLATFORM" then 
       --ThrottlePos = targetLongSpeed --TODO Change this to better represent target speed
      elseif MM == "TRAVEL" or MM == "CRUISE" then 
       targetLongSpeed = ThrottlePos
      end
      
      -- widgets complete thrust override
      for _, cWidget in ipairs(customWidgets) do
       local longSpeed, latSpeed, vertSpeed, otAVx, otAVy, otAVz = cWidget:flushOverRide()
       if longSpeed ~= nil then
        tAVx, tAVy, tAVz = otAVx, otAVy, otAVz
        targetLatSpeed = latSpeed
        targetLongSpeed = longSpeed
        targetVertSpeed = vertSpeed
        overRide = true
        break
       end
      end

      local SBF = inspace == 1 and P.ES.spB.value or 1
      local LBF = P.ES.loB.value
      local lBF = P.ES.laB.value
      local vBF = P.ES.vtB.value

      -- Hold Position, No inputs --
      local hold = false
      if finalPitchInput==0 and finalRollInput==0 and finalYawInput==0 and upInput==0 and not modeRocket and not autoLand and ThrottlePos == 0 and xyzSpeedKPH < 1 
      --and MM ~= "CRUISE" and MM ~= "DRONE" 
      then
       hold = true
      end

      if brakeInput == 1 or hold then
       longBx, longBy, longBz = Nav:composeBrakeAcceleration("longitudinal",0)
       latBx, latBy, latBz = Nav:composeBrakeAcceleration("lateral",0)
       vertBx, vertBy, vertBz = Nav:composeBrakeAcceleration("vertical",0)
       brakeAx, brakeAy, brakeAz = longBx*LBF + latBx*lBF + vertBx*vBF,
        longBy*LBF + latBy*lBF + vertBy*vBF,
        longBz*LBF + latBz*lBF + vertBz*vBF
       autoBrake = true
      else
       if MM == "TRAVEL" and overRide == false then
        if xyzSpeedKPH < P.AS.aBS.value and P.AS.aBS.value > 0 and ThrottlePos == 0 then
         targetLongSpeed = 0
         autoBrake = true
        else
         targetLongSpeed = ySpeedKPH
        end
       end
       if abs(ySpeedKPH) > abs(targetLongSpeed) or sign(ySpeedKPH) ~= sign(targetLongSpeed) or targetLongSpeed == 0 then autoBrake = true end
       longBx, longBy, longBz = Nav:composeBrakeAcceleration("longitudinal",targetLongSpeed)

       if (MM == "DRONE" or overRide == true) and P.AS.iAB.value == false then
        latBx, latBy, latBz = Nav:composeBrakeAcceleration("lateral",targetLatSpeed)
        vertBx, vertBy, vertBz = Nav:composeBrakeAcceleration("vertical",targetVertSpeed)
        brakeAx, brakeAy, brakeAz = longBx*LBF*SBF + latBx*lBF*SBF + vertBx*vBF*SBF,
         longBy*LBF*SBF + latBy*lBF*SBF + vertBy*vBF*SBF,
         longBz*LBF*SBF + latBz*lBF*SBF + vertBz*vBF*SBF
       end

       if P.AS.iAB.value == true then
        local alignmentFactor = inspace == 0 and P.AS.aAD.value or P.AS.sAD.value
        if 180 - abs(Az) < 180 * alignmentFactor then
         latBx, latBy, latBz = Nav:composeBrakeAcceleration("lateral",targetLatSpeed)
         autoBrake = true
        end
        if 180 - abs(Ax) < 180 * alignmentFactor then
         vertBx, vertBy, vertBz = Nav:composeBrakeAcceleration("vertical",targetVertSpeed)
         autoBrake = true
        end
        brakeAx, brakeAy, brakeAz = longBx*LBF*SBF + latBx*lBF*SBF*(1+abs(Az/180)) + vertBx*vBF*SBF*(1+abs(Ax/180)),
         longBy*LBF*SBF + latBy*lBF*SBF*(1+abs(Az/180)) + vertBy*vBF*SBF*(1+abs(Ax/180)),
         longBz*LBF*SBF + latBz*lBF*SBF*(1+abs(Az/180)) + vertBz*vBF*SBF*(1+abs(Ax/180))
       end
      end

      -- Thrust Composer
      if MM == "TRAVEL" and overRide == false then
       longAx, longAy, longAz = Nav:composeAccelerationFromThrottle()
      else
       longAx, longAy, longAz = Nav:composeAccelerationFromTargetSpeed("longitudinal",targetLongSpeed)
      end
      latAx, latAy, latAz = Nav:composeAccelerationFromTargetSpeed("lateral",targetLatSpeed)
      vertAx, vertAy, vertAz = Nav:composeAccelerationFromTargetSpeed("vertical",targetVertSpeed)

      --Space brakes holding in position, no need for eng.
      if inspace == 1 and targetLongSpeed == 0 and ThrottlePos == 0 and upInput == 0 and strafeInput == 0 and xyzSpeedKPH < 3 then
       longAx, longAy, longAz = 0, 0, 0
       latAx, latAy, latAz = 0, 0, 0
       vertAx, vertAy, vertAz = 0, 0, 0
      end

      -- Torque
      local vF = 500/(deltaTick*1000) -- 2 frames per sampling resolution
      local aVCF = P.ES.anD.value
      if finalYawInput ~= 0 or finalPitchInput ~= 0 or finalRollInput ~= 0 then aVCF = 1 end
      if (tAVxPID == nil) then tAVxPID = pid.new(1,0,0) end --cMAS*1.2,0.02,2*aVCF
      tAVxPID:inject((tAVx - cWAngVx)*vF*aVCF - wAFAAx)
      if (tAVyPID == nil) then tAVyPID = pid.new(1,0,0) end
      tAVyPID:inject((tAVy - cWAngVy)*vF*aVCF - wAFAAy)
      if (tAVzPID == nil) then tAVzPID = pid.new(1,0,0) end
      tAVzPID:inject((tAVz - cWAngVz)*vF*aVCF - wAFAAz)
      local angAccelx = tAVxPID:get()
      local angAccely = tAVyPID:get()
      local angAccelz = tAVzPID:get()
      unit.setEngineCommand('torque', {0,0,0}, {angAccelx, angAccely, angAccelz}, 1, 1, '', '', '', 1)

      -- Thrust
      local allx,ally,allz = longAx + latAx + vertAx, longAy + latAy + vertAy, longAz + latAz + vertAz
      local tags = "airfoil,not_ground thrust"
      if P.ES.hov.value == "ON" then
       tags = tags..",ground"
      else
       unit.setEngineCommand("ground", {0,0,0}, {0,0,0}, 0, 1, '', '', '', 1)
      end
      unit.setEngineCommand(tags, {allx,ally,allz}, {0,0,0}, 0, 1, 'airfoil', 'hover_engine', 'eco', 0)

      -- Brake
      unit.setEngineCommand('brake', {brakeAx, brakeAy, brakeAz}, {0,0,0}, 0, 1, '', '', '', 1)

     else
      unit.setEngineCommand('thrust, torque', {0,0,0}, {0, 0, 0}, 1, 1, '', '', '', 1)
      local longBx, longBy, longBz = Nav:composeBrakeAcceleration("longitudinal",0)
      local latBx, latBy, latBz = Nav:composeBrakeAcceleration("lateral",0)
      local vertBx, vertBy, vertBz = Nav:composeBrakeAcceleration("vertical",0)
      local brakeAx, brakeAy, brakeAz = longBx + latBx + vertBx, longBy + latBy + vertBy, longBz + latBz + vertBz
      unit.setEngineCommand('brake', {brakeAx, brakeAy, brakeAz}, {0,0,0}, 0, 1, '', '', '', 1)
     end
    end